Title : Petr4 Semantics
Title Note: version 0.0.1
Title Footer: &date;
Author: The Petr4 Team
Heading depth: 5
Pdf Latex: xelatex
Document Class: [11pt]article
Package: [top=1in, bottom=1.25in, left=1in, right=1in]geometry
Package: fancyhdr
Package: mathpartir
Package: textcomp
Package: mathtools
Package: xspace

.mathpre {
  replace: "/( +)\|-( +)/\1\vdash{}\2/g";
  replace: "/( +)-\|( +)/\1\dashv{}\2/g";
  replace: "/-\>/\to{}/g";
  replace: "/\bG([^a-zA-Z])/\Gamma{}\1/g";
  replace: "/\bD([^a-zA-Z])/\Delta{}\1/g";
  replace: "/\bS([^a-zA-Z])/\Sigma{}\1/g";
  replace: "/\bt([^a-z])/\tau{}\1/g";
  replace: "/</\langle{}/g";
  replace: "/>/\rangle{}/g";
  replace: "/\b:=\b/\coloneqq{}/g";
}

Infer {
  replace:"/(\n|^)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
           \\infer{{}}{\3}{\textsc{\2}}/m";
  replace:"/([\s\S]*?)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
           \\infer{\1}{\3}{\textsc{\2}}/m";
  replace:"~ Begin MathPre {.infer}&nl;&nl;&source;&nl;\
           ~ End MathPre";
}

Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}

@if html {
body.madoko {
  font-family: utopia-std, serif;
}
title,titlenote,titlefooter,authors,h1,h2,h3,h4,h5 {
  font-family: helvetica, sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: monospace;
  font-size: 10pt;
}
}

@if tex {
body.madoko {
  font-family: UtopiaStd-Regular;
}
title,titlenote,titlefooter,authors {
  font-family: sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: LuxiMono;
  font-size: 75%;
}
}

Colorizer: p4
.token.keyword    {
    font-weight: bold;
}

@if html {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  padding:6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}

@if tex {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  breakable: true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}


@if html {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  breakable : true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

p4mathgrammar {
  replace:"/\/\/(.*)/\/\/ &\text{\1}/g";
  replace: "~ Begin P4MathGrammarBlock&nl;\
                 ~ Begin MathPre&nl;&source;&nl;~ End MathPre&nl;\
                 ~ End P4MathGrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}

[TITLE]

~ Begin Abstract
The goal of the Petr4 project is to define a formal semantics for the
P4 Programming Language.
~ End Abstract

[TOC]

# Introduction { #sec-introduction }
# Syntax { #sec-syntax }

## Expression Syntax

~ Begin P4MathGrammar
e ::= @true
    | @false
    | a // arbitrary width integer literal
    | nwa // unsigned integer literal of size n
    | nsa // signed integer literal of size n
    | u // strings
    | x // name
    | .x // top level name
    | e1[e2] // array access
    | e1[e2:e3] // bitslice
    | \{ \overline{e} \} // list
    | \{ \overline{name=e} \} // records
    | uop e
    | e1 binop e2
    | (t) e // explicit cast
    | X.name // type member
    | @error.name // errors
    | e.name // expression member
    | e1 ? e2 : e3 // ternary operator
    | f<\overline{t}>(\overline{e}) // function call (positional)
    | f<\overline{t}>(\overline{x=e}) // function call (named)
    | t(\overline{e}) // nameless instantiation
    | e1 \texttt{\&\&\&} e2 // mask
    | e1 .. e2 // range
~ End P4MathGrammar

~ Begin P4Grammar
// unary operators
uop ::= ! // not
      | - // unary minus
      | ~ // bitwise complement/not

// binary operators
binop ::= +
        | |+|
        | -
        | |-|
        | *
        | /
        | %
        | <<
        | >>
        | <
        | >
        | <=
        | >=
        | ==
        | !=
        | &
        | ^
        | |
        | ++
        | &&
        | ||
~ End P4Grammar

## Statement and Block Syntax
~ Begin P4MathGrammar
s ::= e<\overline{t}>(\overline{e})     // method calls (positional)
    | e<\overline{t}>(\overline{x=e})   // method calls (named)
    | e := e                            // assignment
    | t.@apply(\overline{e})             // direct type invocation
    | @if (e) s_1 @else s_2             // conditional statement
    | blk                               // block statement
    | @exit                             // exit statement (only in controls)
    | \mathkw{;}                        // empty statement
    | @return                           // return (void)
    | @return e                         // return (with value)
    | @switch (e) \{ \overline{case} \} // switch statement
    | decl                              // declaration statement

case ::= case\_lbl: blk  // label with block
       | case\_lbl: {}   // fallthrough

case\_lbl ::= x                // name (of action)
            | \texttt{default} // catch-all label

blk ::= \{ s_1; ... s_n; \} // blocks
~ End P4MathGrammar

## Declaration Syntax
~ Begin P4MathGrammar
decl ::= @const t x:=e
       | t x(\overline{e})
       | t x(\overline{e}) blk
       | @parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} \}
       | @control X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} @apply blk \}
       | @function t x<\overline{X}>(\overline{x:t,d}) blk
       | \mathkw{extern\ function} t x<\overline{X}>(\overline{x:t,d})
       | t x
       | t x := e
       | \mathkw{value\_set}<t>(e) x
       | @action x (\overline{x:t,d_0},\overline{x:t}) blk
       | @table x \{ \overline{prop} \}
       | @header X \{ \overline{x:t} \}
       | \mathkw{header\ union} X \{ \overline{x:t} \}
       | @struct X \{ \overline{x:t} \}
       | @error \{ \overline{x} \}
       | \mathkw{match\_kind} \{ \overline{x} \}
       | @enum X \{ \overline{x} \}
       | @enum t X \{ \overline{x=e} \}
       | @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}
       | @typedef t X
       | @type t X
       | @control X<\overline{X}>(\overline{x:t,d})
       | @parser X<\overline{X}>(\overline{x:t,d})
       | @package X<\overline{X}>(\overline{x:t})

state ::= @state x \{ \overline{s}; @transition state\_expr \}

state\_expr ::= x
              | @select (\overline{e}) \{ \overline{matches:x} \}

matches = \overline{match}

match ::= \mathkw{\_}
        | e

ctor ::= X(\overline{x:t})

method ::= @abstract t x<\overline{X}>(\overline{x:t,d})
         | t x<\overline{X}>(\overline{x:t,d})

prop ::= @key = \{ \overline{e:x} \}
       | @actions = \{ \overline{action\_ref} \}
       | @const @entries = \{ \overline{matches:action\_ref} \}
       | x = e
       | @const x = e

action\_ref ::= x(\overline{e})
~ End P4MathGrammar

## Program Syntax
A program is a sequence of declarations.
~ Begin P4MathGrammar
P ::= decl, P
    | ()
~ End P4MathGrammar

## Type Syntax

~ Begin P4MathGrammar
t ::= @bool
    | @string
    | @int
    | @int<w>
    | @bit<w>
    | @varbit<w>
    | t[a]
    | @tuple<\overline{t}>
    | \{ \overline{t} \}
    | \{ \overline{f:t} \}
    | @set<t>
    | @error
    | \mathkw{match\_kind}
    | X  // type name
    | .X // top level type reference
    | @newtype X t
    | @void
    | @header \{ \overline{f:t} \}
    | \mathkw{header\ union} \{ \overline{f:t} \}
    | @struct \{ \overline{f:t} \}
    | @enum X \{ \overline{x} \}
    | @enum t X \{ \overline{x=v} \}
    | t<\overline{t}> // specialized type
    | @package<\overline{X}>(\overline{x:t,d})
    | @control<\overline{X}>(\overline{x:t,d})
    | @parser<\overline{X}>(\overline{x:t})
    | @extern X \{ \overline{method} \}
    | @function<\overline{X}>(\overline{x:t,d}) : \tau
    | @action(\overline{x:t,d_0}, \overline{x:t}) : @void
    | @constructor<\overline{X}>(\overline{x:t}): t
    | @table X

d0 ::= @in
     | @out
     | @inout

d ::= d0 | @none
~ End P4MathGrammar

Signals are types for statements.
~ P4MathGrammar
sig := @returns // written ``Void" in the implementation
     | \bot     // written ``Unit" in the implementation
~

Contexts indicate where a statement is being typechecked.
~ P4MathGrammar
ctx ::= @InFunction t
      | @InControl
      | @InParser
      | @InAction
~

## Value Syntax

$a \in \mathbb{Z}$

$n \in \mathbb{N}$

$\mathbb{Z}_n ::= m \% 2^n | m \in \mathbb{Z}$

$m_u^n \in \mathbb{Z}_n$

$m_s^n \in \mathbb{Z}_{n-1} \cup \{ -x | x \in \mathbb{Z}_n\}$

Locations in memory:  $\ell$

Values
~ Begin P4MathGrammar
v_o ::= b // booleans
    | a // arbitrary-width integers
    | m_u^n // unsigned integers, n not zero
    | m_s^n // signed integers, n not zero
    | (n, m_u^{n'}) // variable-size bitstrings, n less than n'
    | u // strings
    | (\overline{v}) // tuples
    | \{ \overline{name=v} \} // records
    | set
    | @error.name
    | @matchkind name
    | \xi_{closure} \otimes (\overline{x:t,d}) \to blk // functions, actions
    | @builtin name lv_o
    | @struct \{ \overline{(name, v)} \}
    | @header b \{ \overline{(name, v)} \}
    | \mathkw{header\ union} \{ \overline{(name, v)} \}
    | (\overline{v}, n_{size}, n_{next}) // stacks
    | name1.name2 // enumfield
    | (name1.name2, v) // senumfield
    | (\ell, name_{object}) // stateful runtime
    | @parser \overline{(name, v)} (\overline{x:t,d}) \overline{decl} \overline{state}
    | @control \overline{(name, v)} (\overline{x:t,d}) \overline{decl} blk
    | @package \overline{(name, v)}
    | @table name \overline{e:x} \overline{action\_ref} action\_ref_default \{ \overline{matches:action\_ref} \}
    | @extern name v

v ::= v_o | @None
~ End P4MathGrammar

Sets
~ Begin P4MathGrammar
set ::=  @universal
    | @singleton w v
    | v1 \texttt{\&\&\&} v2 // mask
    | v1 .. v2 // range
    | @product \overline{set}
    | @lpm w v1 v2
    | \mathkw{value\_set} \overline{matches} \overline{set}
~ End P4MathGrammar

## L-value Syntax
~ Begin P4MathGrammar
lv_o ::=  @lvalue t x
    | @lvalue t lv.x
    | @lvalue t lv[n1:n2]
    | @lvalue t lv[v]

lv ::= lv_o | @None
~ End P4MathGrammar

## Signal Syntax
~ Begin P4MathGrammar
sig ::= \mathkw{sig\_continue}
    | \mathkw{sig\_return} v
    | \mathkw{sig\_exit}
    | \mathkw{sig\_reject} v
~ End P4MathGrammar

# Static Semantics { #sec-static }

## Typing contexts

All typing judgments include

1. $\Sigma$, the values of any compile-time-known constants,
2. $\Delta$, the definitions of type names in scope, and
3. $\Gamma$, the types of variables in scope.

Type variables are tracked by mapping type names $X$ to themselves in
the context $\Delta$. Equivalently there could be another context that
was a list of lists of type variables, without them being mapped to
anything.

~ MathPre
\sigma ::= \sigma, x=v | []

S ::= S, \sigma{} | []

\delta ::= \delta, X=t | []

D ::= D, \delta{} | []

\gamma ::= \gamma, x:t,d | []

G ::= G, \gamma{} | []
~

In all contexts there is a lookup test $C(x) = y$ which searches from
the outermost list of bindings inward and a top level lookup $C(.x) =
y$ which only looks at the innermost list of bindings.

## Helper Judgments

### Numeric types
~ MathPre
@numeric(t) = \begin{cases} true & t = int
true & t = int<w>
true & t = bit<w>
false & \text{otherwise}
\end{cases}
~

### Left-value Judgment

Left-values or lvalues are expressions that can appear on the left
side of an assignment $e:=e$.  The judgment has the form
~ MathPre
e @lvalue
~
and is defined inductively by the following rules.

~ Infer

-------------[Name-LValue]
x @lvalue
~

~ Infer

-------------[Top-Level-Name-LValue]
.x @lvalue
~

~ Infer
e @lvalue
--------------[Member-LValue]
e.x @lvalue
~

~ Infer
e1 @lvalue
----------------[Index-LValue]
e1[e2] @lvalue
~

~ Infer
e @lvalue
----------------[Slice-LValue]
e[n1:n2] @lvalue
~

## Expression Typing
### Type Constants

~ Infer

------------------------[Bool-True]
 S,D,G |- @true : @bool, @none
~

~ Infer

------------------------[Bool-False]
 S,D,G |- @false : @bool, @none
~

~ Infer

------------------------[String]
 S,D,G |- u : @string, @none
~

~ Infer

------------------------[Int-Constant]
S,D,G |- a : @int, @none
~

~ Infer

------------------------[Signed-Int-Constant]
S,D,G |- nsa : @int<n>, @none
~

~ Infer

------------------------[Unsigned-Int-Constant]
S,D,G |- nwa : @bit<n>, @none
~

### Type Variables

~ Infer
G(x) = t, d
-------------------[Var]
S,D,G |- x : t, d
~

~ Infer
G(.x) = t, d
----------------------[Var-Top]
S,D,G |- .x : t, d
~

### Type Accesses

~ Infer
S,D,G |- e_1 : t_1[], d_1
S,D,G |- e_2  : t_2, \_
@numeric(t_2)
----------------------[Array-Access]
S,D,G |- e_1[e_2] : t_1, d_1
~

~ Infer
S,D,G |- e_1 : @bit<w>, d_1
S,D,G |- e_2  : t_2, \_
@numeric(t_2)
S,D,G |- e_3  : t_3, \_
@numeric(t_3)
0 \leq S(e_2)
S(e_2) \lt w
S(e_2) \geq S(e_3)
S(e_3) \lt w
------------------------[Slice]
S,D,G |- e1[e2:e3] : bit<S(e_2) - S(e_3) + 1>, d_1
~

~ Infer
S,D,G |- \overline{e: \tau, none}
-----------------------------------------------[List-Expression]
S,D,G |- \{ \overline{e} \} : \{ \overline{\tau} \}, none
~

### Type Unary Operations

~ Infer
S,D,G |- e : @bool, d
-------------------[Not]
S,D,G |- !e : @bool, d
~

~ Infer
S,D,G |- e : @bit<w>, d
-----------------------------[Bitwise-Not]
S,D,G |- {\texttt{\textasciitilde}e} : @bit<w>, d
~

~ Infer
S,D,G |- e : t, d
@numeric(t)
--------------------[Negate]
S,D,G |- {-e} : t, d
~

### Type Binary Operations

```haskell
  fun binaryDir In In = In
    | binaryDir _  _  = none
```

~ Infer
S,D,G |- e_1 : @bool, d_1
S,D,G |- e_2 : @bool, d_2
\diamond \in \{ \&\&, || \}
------------------------------------------------------------------[Bool-Binary-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @bool, @binaryDir(d_1, d_2)
~

~ Infer
S,D,G |- e_1 : @int, d_1
S,D,G |- e_2 : @int, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq, /, \% \}
--------------------------------------------------------[Int-Binary-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @int, @binaryDir(d_1, d_2)
~

~ Infer
S,D,G |- e_1 : @int<w>, d_1
S,D,G |- e_2 : @int<w>, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-| \}
-----------------------------------------------------------[Int-Signed-Binary-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @int<w>, @binaryDir(d_1, d_2)
~

~ Infer
S,D,G |- e_1 : @bit<w>, d_1
S,D,G |- e_2 : @bit<w>, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-|,\&,\hat{},|,\oplus \}
----------------------------------------------------------[Int-Unsigned-Binary-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @bit<w>, @binaryDir(d_1, d_2)
~

<!--
need to define has_equality
-->

~ Infer
S,D,G |- e_1 : t, d_1
S,D,G |- e_2 : t, d_2
\mathkw{has\_equality}(t)
\diamond \in \{ ==,!= \}
----------------------------------------------------------[Equality-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @bool, @binaryDir(d_1, d_2)
~

~ Infer
S,D,G |- e_1 : @bit<l>, d_1
S,D,G |- e_2 : @bit<r>, d_2
---------------------------------[Bit-Concat-Op]
S,D,G |- e_1 \mathbin{++} e_2 : @bit<l+r>, @binaryDir(d_1, d_2)
~

~ Infer
S,D,G |- e_1 : t_1, d_1
S,D,G |- e_2 : t_2, d_2
@numeric(t_1)
t_2 = @bit<\_> \lor t_2 = @int
\diamond \in \{\ll, \gg\}
---------------------------------[Shift-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : t_1, @binaryDir(d_1, d_2)
~

### Type Casts

Casting from $\tau_0$ to $\tau$ is permitted by the
$\tau \prec \tau'$ judgment.

The equality sign here hasn't been defined and probably won't make
sense without adding a context for looking up variables and type
names.
~ Infer
t = t'
-------------------------------------------[]
t \mathrel{\prec} t'
~

~ Infer

---------------------[]
@int \mathrel{\prec} @int<w>
~
~ Infer

---------------------[]
@int \mathrel{\prec} @bit<w>
~

~ Infer

----------------------------------------------------[]
\{t_1, \dots, t_n\} \mathrel{\prec} @tuple<t_1, \dots, t_n>
~

~ Infer

----------------------------------------------------[]
\{t_1, \dots, t_n\} \mathrel{\prec} @header \{f_1: \tau_1, ..., f_n: \tau_n\}
~

~ Infer

----------------------------------------------------[]
\{t_1, \dots, t_n\} \mathrel{\prec} @struct \{f_1: \tau_1, ..., f_n: \tau_n\}
~

~ Infer

----------------------------------------------------[]
t \mathrel{\prec} @enum t X \{m_1, ..., m_n\}
~

~ Infer

-------------------------------------------[]
@enum t X \{m_1, ..., m_n\} \mathrel{\prec} t
~

~ Infer

-------------------------------[]
@newtype X t \mathrel{\prec} t
~

~ Infer

-------------------------------[]
t \mathrel{\prec} @newtype X t
~

~ Infer
S,D,G |- e : t_0, d
t_0 \prec t
------------------------[Cast]
S,D,G |- (t) e : t, @none
~

### Type Member expressions
~ Infer
D(X) = @enum t X \{m_1,\dots,m_n\}
---------------------------------------[Type-Member-Serializable-Enum]
S,D,G |- X.m_i:X,@none
~

~ Infer
D(X) = @enum X \{m_1,\dots,m_n\}
---------------------------------------[Type-Member-Enum]
S,D,G |- X.m_i:X,@none
~

~ Infer
G(@error.name) = @error
-------------------------------------[Error-Member]
S,D,G |- @error.name : @error, @none
~

Field and method lookups on expressions are delegated to another
judgment $\mathkw{has\_field}\ t\ name\ t_{name}$.
~ Infer
S,D,G, |- e : t, d
\mathkw{has\_field} t name t_{name}
------------------------------------[Expression-Member]
S,D,G |- e.name : t_{name}, @none
~

~ Infer

---------------------------------------------------------------------[Header-Field]
\mathkw{has\_field} (@header \{f_1:t_1, \dots, f_n:t_n\}) f_i t_i
~

~ Infer

--------------------------------------------------------------------------------[Header-Union-Field]
\mathkw{has\_field} (\mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}) f_i t_i
~

~ Infer

-------------------------------------------------------------------[Struct-Field]
\mathkw{has\_field} (@struct \{f_1:t_1, \dots, f_n:t_n\}) f_i t_i
~

~ Infer

---------------------------------------------------------------------------------[Header-IsValid-Field]
\mathkw{has\_field} (@header \{f_1:t_1, ... , f_n:t_n\}) @isValid (() -> @bool)
~

~ Infer

---------------------------------------------------------------------------------[Header-SetValid-Field]
\mathkw{has\_field} (@header \{f_1:t_1, ... , f_n:t_n\}) @setValid (() -> @void)
~

~ Infer

-----------------------------------------------------------------------------------[Header-SetInvalid-Field]
\mathkw{has\_field} (@header \{f_1:t_1, ... , f_n:t_n\}) @setInvalid (() -> @void)
~

~ Infer

---------------------------------------------------------------------------------------------[HeaderUnion-IsValid-Field]
\mathkw{has\_field} (\mathkw{header\ union} \{f_1:t_1, ... , f_n:t_n\}) @isValid (() -> @bool)
~


~ Infer

--------------------------------------------------------------------------------[Control-Apply-Field]
\mathkw{has\_field} (@control \{f_1:t_1, ... , f_n:t_n\}) @apply (() -> @void)
~

~ Infer

-------------------------------------------------------------------[Parser-Apply-Field]
\mathkw{has\_field} (@parser \{f_1:t_1, ... , f_n:t_n\}) @apply (() -> @void)
~

~ Infer

-------------------------------------------------------------------[Table-Apply-Field]
\mathkw{has\_field} (@table X) @apply (() -> X)
~

~ Infer

-------------------------------------------------------------------[Array-Size-Field]
\mathkw{has\_field} t[a] @size @bit<32>
~

~ Infer

-------------------------------------------------------------------[Array-LastIndex-Field]
\mathkw{has\_field} t[a] @lastIndex @bit<32>
~

~ Infer

-------------------------------[Array-Next-Field]
\mathkw{has\_field} t[a] @next t
~

~ Infer

-------------------------------[Array-Last-Field]
\mathkw{has\_field} t[a] @last t
~

~ Infer

-------------------------------[Array-PushFront-Field]
\mathkw{has\_field} t[a] \mathkw{push\_front} ((count: @int) -> @void)
~

~ Infer

-------------------------------[Array-PopFront-Field]
\mathkw{has\_field} t[a] \mathkw{pop\_front} ((count: @int) -> @void)
~


### Type Ternary Expression

~ Infer
S,D,G |- e_1 : @bool, \_
S,D,G |- e_2 : t, \_
S,D,G |- e_3 : t, \_
--------------------------------[Ternary-Op]
S,D,G |- e_1 ? e_2 : e_3 : t, @none
~

### Type Function Calls
TODO: Handle overloads of extern functions

Function Call Argument Predicate $P_{call}$:
~ MathPre
@P_{call} = \forall e,t,d,
  d = @in \Rightarrow t \neq @extern X \{ \overline{method} \} \wedge
  d = @out \Rightarrow e @lvalue \wedge
  d = @inout \Rightarrow e @lvalue \wedge
  d = @none \Rightarrow @True
~

~ Infer
S,D,G |- f : function<\overline{X}>(\overline{x:t,d}):t_{\mathsf{ret}}, \_
P,S,D[\overline{X \to \rho}],G |- \overline{e:t,d}
\overline{@P_{call} \, e \, d \, t}
----------------------------------------------------------------------------[Function-Call]
S,D,G |- f<\overline{\rho}>(\overline{e}):\tau_{\mathsf{ret}}, @none
~

~ Infer
S,D,G |- f : function<\overline{X}>(\overline{x:t,d}):t_{\mathsf{ret}}, \_
P,S,D[\overline{X \to \rho}],G \vdash \overline{e:t}
\overline{@P_{call} \, e \, d \, t}
----------------------------------------------------------------------------[Action-Call]
S,D,G |- f<\overline{\rho}>(\overline{e}):\tau_{\mathsf{ret}}, @none
~

### Type Nameless Instantiation

We need a function to resolve overloads.
~ Infer
t_{ctor} = @constructor<\overline{X}>(\overline{x:t}): t
@length \overline{x:t} = n
X:t_{ctor} \in G
---------------------------------------------------------[Resolve-Constructor-Overload]
\mathkw{resolve\_overload} G X n = t_{ctor}
~

~ Infer
@length \overline{e} = n
@length \overline{\rho} = @length \overline{X}
\mathkw{resolve\_overload} G Y n = @constructor<\overline{X}>(\overline{x:t}): t_{ret}
S,D[\overline{X \to \rho}],G \vdash \overline{e:t}
--------------------------------------------------------------------[Specialized-Type-Instantiation]
S,D,G |- Y<\overline{\rho}>(\overline{e}) : t_{ret}[\overline{\rho/X}]
~

~ Infer
S,D,G |- X<>(\overline{e}) : t
----------------------------------[Simple-Type-Instantiation]
S,D,G |- X(\overline{e}) : t
~

### Type Set Operations

TODO: the Masks rule is based off of the spec
and diverges from the type checker's implementation

~ Infer
S,D,G |- e_1 : @bit<w>, \_
S,D,G |- e_2 : @bit<w>, \_
------------------------------------------------[Masks]
S,D,G |- e_1 \texttt{\&\&\&} e_2 : @set<@bit<w>>,@none
~

~ Infer
S,D,G |- e_1 : \tau, \_
S,D,G |- e_2 : \tau, \_
\tau = @bit<w> \lor \tau = @int<w>
-------------------------[Ranges]
S,D,G |- e_1\mathbin{..}e_2 : @set<\tau>, @none
~

## Statement Typing

Statements are typed by a judgment of the form
~ MathPre
S,D,G,ctx |- s:sig -| G'.
~

The judgment is defined inductively by the following rules.

~ Infer
S,D,G |- e<\overline{t}>(\overline{e}):t
-------------------------------------------------------[Type-Stmt-Method-Call]
S,D,G,ctx |- e<\overline{t}>(\overline{e}):\bot -| G
~

~ Infer
\mathkw{lvalue}(e_l)
S,D,G |- e_l: t
S,D,G |- e_r: t
----------------------------[Type-Stmt-Assignment]
S,D,G,ctx |- e_l:=e_r:\bot -| G
~

~ Infer
S,D,G |- t().@apply(\overline{e}) : t'
----------------------------------------------[Type-Stmt-Direct-Application]
S,D,G,ctx |- t.@apply(\overline{e}):bot -| G
~

The $\wedge{}$ operator is $\mathkw{returns}$ if both of its arguments
are $\mathkw{returns}$ and $\bot$ otherwise. The $\vee{}$ operator is
$\mathkw{returns}$ if any of its arguments are $\mathkw{returns}$
and $\bot$ otherwise.

~ Infer
S,D,G |- e:@bool,\_
S,D,G,ctx |- s:sig -| G'
----------------------------------[Type-Stmt-If]
S,D,G,ctx |- @if (e) s :\bot -| G
~

~ Infer
S,D,G |- e:@bool
S,D,G,ctx |- s_1:sig_1 -| G_1
S,D,G,ctx |- s_2:sig_2 -| G_2
----------------------------------------------[Type-Stmt-If-Else]
S,D,G,ctx |- @if (e) s_1 @else s_2:sig_1\wedge{}sig_2 -| G
~

We need another judgment for typing sequences $\overline{s}$ of
statements. (Sorry about the empty sequence notation in the first
rule...)

~ Infer

---------------------------------------------------[Type-Stmts-Empty]
S,D,G,ctx |- \overline{  } :\bot -| G
~

~ Infer
S,D,G,ctx  |- s:sig_1 -| G'
S,D,G',ctx |- \overline{s}:sig_2 -| G'
---------------------------------------------------[Type-Stmts-List]
S,D,G,ctx |- s;\overline{s}:sig_1 \vee sig_2 -| G
~

~ Infer
S,D,G,ctx |- \overline{s}:sig -| G'
---------------------------------------[Type-Stmt-Block]
S,D,G,ctx |- \{\overline{s}\}:sig -| G
~

~ Infer

---------------------------------------------------[Type-Stmt-Exit]
S,D,G,@InParserState |- @exit:@returns -| G
~

~ Infer

------------------------------------------[Type-Stmt-Empty]
S,D,G,ctx |- \mathkw{;}:\bot -| G
~

~ Infer
S,D,G |- e:t
---------------------------------------------------[Type-Stmt-Return-Value]
S,D,G,@InFunction t |- @return e:@returns -| G
~

~ Infer

---------------------------------------------------[Type-Stmt-Return-Void]
S,D,G,@InFunction @void |- @return:@returns -| G
~

~ Infer

---------------------------------------------------[Type-Stmt-Return-Control]
S,D,G,@InControl |- @return:@returns -| G
~

~ Infer

---------------------------------------------------[Type-Stmt-Return-Action]
S,D,G,@InAction |- @return:@returns -| G
~

~ Infer
S,D,G |- case\_lbl : \tau
S,D,G,@InControl |- blk:sig -| G'
---------------------------------------------------[Type-Case-Block]
S,D,G |- \mathkw{case\_ok}_\tau (case\_lbl:blk)
~

~ Infer
S,D,G |- case\_lbl : \tau
---------------------------------------------------[Type-Case-Fallthrough]
S,D,G |- \mathkw{case\_ok}_\tau (case\_lbl:{})
~

There isn't a real reason to track signals in controls, seeing as
controls only return void and there's no way for an apply block that
typechecks in all other respects to fail to not return a value. Seeing
as switch statements can only appear in controls, this rule just
assigns them the signal $\bot$ to avoid having to track signals in
each case and across fallthrough cases.
~ Infer
S,D,G |- e : @enum X \{ \overline{m} \}
\forall i. S,D,G |- \mathkw{case\_ok}_X case_i
---------------------------------------------------------------------[Type-Stmt-Switch]
S,D,G,@InControl |- @switch (e) \{ case1, \dots, case_n \}:\bot -| G
~

TODO: DeclarationStatements don't need to exist, see
https://github.com/cornell-netlab/petr4/issues/5

The implementation makes sure decl is a constant, instantiation, or
variable, this rule doesn't bother.
~ Infer
S,D,G |- decl -| S',D',G'.
---------------------------------------------------[Type-Stmt-Declaration-Statement]
S,D,G,ctx |- decl:\bot -| G'
~

## Parser-State Typing

Parser states need their own typing judgment to deal with state-machine control flow. It has the form
~ MathPre
S,D,G,K |- state,
~
where K is a list of names of states used to check that the parser's
transitions make sense. It is defined by two rules, which use another
judgement $\mathkw{state\_expr\_ok}$.

~ Infer
S,D,G,K |- \mathkw{state\_expr\_ok} state\_expr
------------------------------------------------------[Type-State-Transition]
S,D,G,K |- @state x \{ ; @transition state\_expr \}
~

~ Infer
S,D,G |- s0 -| G'
S,D,G' |- \{ \overline{s}; @transition state\_expr \}
----------------------------------------------------------[Type-State-Statement]
S,D,G,K |- @state x \{ s0; \overline{s}; @transition state\_expr \}
~

The $\mathkw{state\_expr\_ok}$ judgment is defined by the following rules.
~ Infer
x\in{}K
-----------------------------------------------[State-Expr-OK-Direct]
G,K |- \mathkw{state\_expr\_ok} x
~

~ Infer
S,D,G |- \overline{e:t}
S,D,G |- \overline{\mathkw{match\_ok} t match}
\overline{x\in{}K}
-----------------------------------------------[State-Expr-OK-Select]
S,D,G,K |- \mathkw{state\_expr\_ok} @select (\overline{e}) \{ \overline{\overline{match}:x} \}
~

TODO: there should be implicit casts inserted in matches so that they always have set type.
TODO: Should matches be a separate kind of expression, or should we fold them into one type?
~ Infer
S,D,G |- e : @set t_m
t_m = t
----------------------------------------[Match-OK-Expr]
S,D,G |- \mathkw{match\_ok} t e
~

~ Infer

-------------------------------------------[Match-OK-DontCare]
S,D,G |- \mathkw{match\_ok} t \mathkw{\_}
~

## Declaration Typing

Declarations are typed by a judgment of the form
~ MathPre
S,D,G |- decl -| S',D',G'.
~

It is defined inductively by the following rules.

~ Infer
S,D,G |- e:t
S, e \Downarrow v
--------------------------------------------[Type-Decl-Const]
S,D,G |- @const x := e -| S[x = v],D,G
~

~ Infer
S,D,G |- t(\overline{e}) : t_{inst}
-----------------------------------[Type-Decl-Instantiation]
S,D,G |- t x(\overline{e}) -| S,D,G[x:t_{inst}]
~

The function $\mathkw{names}(s_1, s_2, \dots)$ takes a list of states
and returns a list of their names.

~ Infer
K = @names(\overline{state}),@accept,@reject
@start \in K
S,D,G[\overline{x^{ctor}:t^{ctor}}][\overline{x:t}] |- \overline{decl} -| S',D',G'
S',D',G',K |- \overline{state}
t_{ctor} = @constructor(\overline{x^{ctor}:t^{ctor}}):@parser(\overline{x:t})
-------------------------------------------------------------------------------------------------------------[Type-Decl-Parser]
S,D,G |- @parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} -| S,D,G[X:t_ctor]
~

~ Infer
S,D,G[\overline{x^{ctor}:t^{ctor}}][\overline{x:t}] |- \overline{decl} -| S',D',G'
S',D',G',@void |- blk -| G''
t_{ctor} = @constructor(\overline{x^{ctor}:t^{ctor}}):@control(\overline{x:t})
-------------------------------------------------------------------------------------------------------------------[Type-Decl-Control]
S,D,G |- @control X(\overline{x: t})(\overline{x^{ctor}:t^{ctor}}) \{ \overline{decl} @apply blk \} -| S,D,G[X:t_ctor]
~

~ Infer
\exists \rho, S,D[\overline{X \to \rho}],G[\overline{x:t}],@InFunction t |- blk: @returns t -| G_{blk}
G' = G[x:@function<\overline{X}>(\overline{x: t}) : t]
----------------------------------------------------[Type-Decl-Function]
S,D,G |- @function t x<\overline{X}>(\overline{x: t,d}) blk -| S,D,G'
~

~ Infer
G' = G[x:@function<\overline{X}>(\overline{x: t,d}) : t]
---------------------------------------------------------------[Type-Decl-Extern-Function]
S,D,G |- \mathkw{extern\ function} t x<\overline{X}>(\overline{x: t,d}) blk -| S,D,G'
~

~ Infer
t x := e
--------------------------------[Type-Decl-Variable]
S,D,G |- t x -| S,D,G[x:t]
~

~ Infer
S,D,G |- e:t
-------------------------------------[Type-Decl-Variable-Initialized]
S,D,G |- t x := e -| S,D,G[x:t]
~

~ Infer

-------------------------------------------------------[Type-Decl-Value-Set]
S,D,G |- \mathkw{value\_set}<t>(e) x -| S,D,G[x:@set t]
~

~ Infer
S,D[\overline{X=X}],G[\overline{x:t}],t |- blk -| G_{blk}
G' = G[x:@action<\overline{X}>(\overline{x:t,d0},\overline{x:t})]
-------------------------------------------------------------------------------[Type-Decl-Action]
S,D,G |- @action x<\overline{X}>(\overline{x:t,d_0},\overline{x:t}) blk -| S,D,G'
~

### Table Typing

Table properties get their own judgment
~ MathPre
S,D,G; K,A |- prop -| K',A'
~
Where $K$ is defined as the types of keys defined in the table, and $A$ is defined as the names and types of actions in the table.

~ Infer
S,D,G |- \overline{e:t}
S,D,G |- \overline{x:\mathkw{match\_kind}}
------------------------------------------------------------------------------[Type-Prop-Keys]
S,D,G; \{\},\{\} |- @key = \{ \overline{e:x} \} -| \{\overline{\tau}\},\{\}
~

~Infer
P(x_a) = @action x_a (\overline{x:t,d_0},\overline{x:t}) blk
S,D,G |- \overline{e:t}
-------------------------------------------------------------------------------------------------------------------------------------------------[Type-Prop-Actions]
S,D,G; K,\{\} |- @actions = \{ \overline{x_a(\overline{e})} \} -| K,\{\overline{x_a:@action(\overline{x:t,d_0}, \overline{x:t}) : @void}\}
~

~ Infer
S,D,G |- \overline{e_m : t_k}
A(x_a) = @action (\overline{x:t,d_0},\overline{x:t}) @void
S,D,G |- \overline{e_a : t}
---------------------------------------------------------------------------------------------------------------------------------[Type-Prop-Entries]
S,D,G; \{\overline{t_k}\},A |- @const @entries = \{ \overline{\overline{e_m}:x_a(\overline{e_a})} \} -| \{\overline{t_k}\},A
~

~ Infer
x \in A
---------------------------------------------------[Type-Prop-Default]
S,D,G,K,A |- \mathkw{default\_action}=x -| K,A
~

~ Infer
S,D,G,\{\},\{\} |- \overline{prop} -| K,\{\overline{x_a:@action(\overline{x:t,d_0}, \overline{x:t}) : @void}\}
D' = D[``action\_list\_<x>" \to @enum ``action\_list\_<x>" \{ \overline{x_a} \}]
D'' = D'[``apply\_result\_<x>" \to @struct \{ ``hit" : @bool; ``action\_run" : @enum ``action\_list\_<x>" \{ \overline{x_a} \} \}]
---------------------------------------------------[Type-Decl-Table]
S,D,G |- @table x \{ \overline{prop} \} -| S,D,G[x \to @table ``apply\_result\_<x>"]
~


### Header and Struct Typing
~ Infer

-----------------------------------------------------------------------------------[Type-Decl-Header]
S,D,G |- @header X \{ \overline{x:t} \} -| S,D[X=@header \{ \overline{x:t} \}],G
~

~ Infer

----------------------------------------------------------------[Type-Decl-Header-Union]
S,D,G |- \mathkw{header\ union} X \{ \overline{x:t} \} -| S,D[X=\mathkw{header\ union} \{ \overline{x:t} \}],G
~

~ Infer

-------------------------------------------------------------------[Type-Decl-Struct]
S,D,G |- @struct X \{ \overline{x:t} \} -| S,D[X=@struct \{ \overline{f:t} \}],G
~

~ Infer
\overline{@error.x \notin G}
-----------------------------------------------------------[Type-Decl-Error]
S,D,G |- @error \{ \overline{x} \} -| S,D,G[\overline{@error.x:@error}]
~

~ Infer
\overline{.x \notin G}
---------------------------------------------------[Type-Decl-Match-Kind]
S,D,G |- \mathkw{match\_kind} \{ \overline{x} \} -| S,D,G[\overline{.x:\mathkw{match\_kind}}]
~

~ Infer
D' = D[X=@enum t X \{ \overline{x} \}]
\overline{e} \Downarrow \overline{v}
---------------------------------------------------[Type-Decl-Enum]
S,D,G |- @enum t X \{ \overline{x=e} \} -| S[\overline{x=v}],D,G
~

~ Infer
D' = D[X=@enum X \{ \overline{x} \}]
---------------------------------------------------[Type-Decl-Serializable-Enum]
S,D,G |- @enum X \{ \overline{x} \} -| S,D,G
~

~ Infer
\forall{}ctor_i=X(\overline{x:t}). {t_{ctor}}_i = @constructor<\overline{X}>(\overline{x_i:t_i}) : t_{extern}
t_{extern} = @extern X \{ \overline{method} \}
---------------------------------------------------[Type-Decl-Extern-Object]
S,D,G |- @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \} -| S,D,G[\overline{X:t_{ctor}}]
~

~ Infer

---------------------------------------------------[Type-Decl-TypeDef]
S,D,G |- @typedef t X -| S,D[X=t],G
~

~ Infer

---------------------------------------------------[Type-Decl-TypeDef]
S,D,G |- @newtype t X -| S,D[X=@newtype X t],G
~

~ Infer
D'=D[X=@control<\overline{X}>(\overline{x:t,d})
--------------------------------------------------------------------[Type-Decl-Control-Type]
S,D,G |- @control X<\overline{X}>(\overline{x:t,d}) -| S,D',G
~

~ Infer
D'=D[X=@parser<\overline{X}>(\overline{x:t,d})
---------------------------------------------------[Type-Decl-Parser-Type]
S,D,G |- @parser X<\overline{X}>(\overline{x:t,d}) -| S,D',G
~

~ Infer
D'=D[X=@package<\overline{X}>(\overline{x:t})
-----------------------------------------------------------------[Type-Decl-Package-Type]
S,D,G |- @package X<\overline{X}>(\overline{x:t}) -| S,D',G
~

## Typing of Programs
Partial programs are checked by a judgment of the form
~ MathPre
S,D,G |- P0 -| S',D',G'.
~
Complete programs are checked by giving empty contexts on the left.

The judgment only needs two rules.

~ Infer

--------------------------[]
S,D,G |- [] -| S,D,G
~

~ Infer
S,D,G |- decl -| S',D',G'
S',D',G' |- P0 -| S'',D'',G''
------------------------------------[]
S,D,G |- decl, P0 -| S'',D'',G''
~

# Dynamic Semantics { #sec-dynamic }

## Evaluation Environment and State
All evaluation rules include

1. $\zeta$, a representation of the control plane
2. $\xi$, an evaluation environment
3. $\sigma$, for maintaining state

The control plane representation contains table entries and value sets. Since
tables already populated with constant entries are immutable, the representation
of the control plane treats entries like constant entries.

$\zeta ::= (\{ \overline{matches:action\_ref} \}, \overline{set})$

$\xi ::= P, E, \Delta, \upsilon$

$P$ is a declaration context representing the program seen so far mapping type names to declarations.
$E$ is a value context mapping names to locations $\ell$ in the state $\sigma$.
$\Delta$ is the same as defined in the typing contexts.
$\upsilon$ is a string namespace used for control plane names.

~ MathPre
\rho ::= \rho, X=decl | []

P ::= P, \rho{} | []

\epsilon ::= \epsilon, x=\ell | []

E ::= E, \epsilon{} | []

\delta ::= \delta, X=t | []

D ::= D, \delta{} | []
~

$\sigma ::= (packet, (\overline{name,object}))$ where $object$ is defined by the target.
$packet$ is used to maintain the state of the packet and $(\overline{name,object})$ is for stateful objects maintained by externs.

$\mathkw{push} \xi$ pushes an empty first-level scope onto each context in $\xi$.
$\mathkw{pop} \xi$ pops the first-level scope off each context in $\xi$ if one exists.
$\mathkw{first\_lvl} \xi$ is the first-level scope of each context in $\xi$ if one exists.

$\xi[z/x]$ is syntactic sugar for $P[z/x]$, $E[z/x]$, or $\Delta[z/x]$ depending on whether
$z$ is a declaration, value, or type, respectively. Similarly $\xi(x) = z$ is syntactic sugar
for $P(x)$, $E(x)$, or $\Delta(x)$ depending on whether $z$ is a declaration, location, or type, respectively.
$\xi[\overline{\ell}/\overline{name}]$ means the bindings $(name_i, \ell_i)$
are inserted into $\xi$ in the order they appear in $(\overline{name,\ell_i})$.

$\mathkw{set\_namespace} \xi x$ is $\xi$ with $\upsilon$ set to $x$ and $\mathkw{namespace} \xi$ is $\upsilon$.
Since $\upsilon$ is a string, the string concatenation operator ^ is used in places.

## Control flow
Signals are threaded through expression and statement evaluation.
Unless otherwise stated, a signal that is not $\mathkw{sig\_continue}$ will result in
a no-op that does not change $\xi$ or $\sigma$ and propagates the signal. In cases
where a value is needed, it will be $\mathkw{None}$ if the input signal is not $\mathkw{sig\_continue}$.

<!--
~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', sig', v>
sig = \mathkw{sig\_continue}
----------------------------------------------------------------------------------
<\zeta, \xi, \sigma, sig, e> \Downarrow_E <\xi', \sigma', sig', v>
~

~ Infer
sig \neq \mathkw{sig\_continue}
----------------------------------------------------------------------------------
<\zeta, \xi, \sigma, sig, e> \Downarrow_E <\xi, \sigma, sig, @None>
~
-->

## Evaluation Helper Rules

### Memory Allocation and Dereferencing

$ \mathkw{new} \, \xi \, \sigma \, x \, v $ allocates memory for value $v$ and returns an updated state and environment.

~MathPre
@new \, \xi \, \sigma \, x \, v = \xi', \sigma'
\text{where}
\ell \text{ is a fresh location in memory}
\sigma' = \sigma[v / \ell]
\xi' = \xi[ \ell / x ]
~

$(\sigma \circ \xi)(x)$ finds the value associated with name $x$.

### Sequence Evaluation
Evaluating sequences such as $\overline{e}$ implies the evaluation  is performed
left-to-right and outputs such as $\xi$, $\sigma$, and $sig$ are threaded through.

### Numeric Value Evaluation
~ MathPre
\mathkw{extract\_num} v = \begin{cases} a & v = a
a & v = a_u^n
a & v = a_s^n
\end{cases}
~

### Bitslice Evaluation
$\mathkw{bitslice} n_1 n_2 n_3$ is the decimal value obtained from interpreting $n_1$ in its binary representation and
converting bits $n_2...n_3$ inclusive to decimal. Bit $n_2$ is more significant than bit $n_3$.


### Copy-In/Copy-Out
~ MathPre
@copyin \, \xi_{closure} \, \sigma \, (x:t,d) \, v = \begin{cases} \xi_{closure},\sigma & d = @out
@new \, \xi_{closure} \, \sigma \, x \, v & otherwise
\end{cases}
~

~ MathPre
@copyout \, \zeta \, \xi_{call} \, \xi_{closure} \, \sigma \, (x:t,d) \, e = \begin{cases} \sigma & d = @in
\sigma & d = @none \land t \neq @extern ...
\sigma' & otherwise, \text{where} \mathkw{lv\_of\_expr} \, \zeta \, \xi_{call} \, \sigma \, e = (\_, \_, \_, lv_o) \land \mathkw{assign\_lv} \, \xi_{call} \, lv_o \, (\sigma \circ \xi_{closure})(x) = (\sigma', \_)
\end{cases}
~

### Match Switch Case
~ MathPre
\mathkw{match\_switch\_case} case_1...case_n name = \begin{cases} None & \forall i \text{ where } 1 \leq i \leq n, name \neq case\_lbl_i \land case\_lbl_i \neq \texttt{default}
None & case_i = case\_lbl_i :\ \land \nexists case\_lbl_j : blk_j, i \lt j
Some\ blk_i & case_i = case\_lbl_i : blk_i \land name = case\_lbl_i
Some\ blk_j & case_i = case\_lbl_i :\ \land case_j = case\_lbl_j : blk_j \land name = case\_lbl_i \land \nexists case\_lbl_h : blk_h, i \lt h \lt j
\end{cases}
~

### Match Sets
~ MathPre
\mathkw{width\_of\_val} v = \begin{cases} w & v = n_u^w
w & v = n_s^w
n1 & v = (n1, {n2}_u^w)
0 & v = @None
1 & v = b
\mathkw{width\_of\_val} v1 +...+\mathkw{width\_of\_val} v_n & v = @struct \{\overline{(name,v)}\}
\mathkw{width\_of\_val} v1 +...+\mathkw{width\_of\_val} v_n & v = @header b \{\overline{(name,v)}\}
\mathkw{width\_of\_val} v' & v = (name1.name2, v')
\end{cases}

\mathkw{set\_of\_matches} \zeta \xi \sigma \overline{match} \overline{w} = \begin{cases} (\xi, \sigma, @universal) & \overline{match} = (\_)
(\xi', \sigma', @singleton w (\mathkw{extract\_num} v)) & \overline{match} = (e) \land \overline{w} = w \land <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
(\xi'', \sigma'', \mathkw{value\_set} \overline{matches} \overline{set}_2) & \overline{match} = (e) \land <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \mathkw{value\_set} \overline{matches} \overline{set}_1> \land \mathkw{set\_of\_matches} \zeta \xi' \sigma' \overline{matches} = (\xi'', \sigma'', \overline{set}_2)
(\xi', \sigma', set) & \overline{match} = (e) \land <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, set> \land set \neq \mathkw{value\_set} ...
(\xi^n, \sigma^n, @product (set_1,...,set_n)) & \overline{match} = (match_1,...,match_n) \land \mathkw{set\_of\_matches} \zeta \xi \sigma (match_1) (w_1) = (\xi', \sigma', set_1) \land ... \land \mathkw{set\_of\_matches} \zeta \xi^{n-1} \sigma^{n-1} (match_n) (w_n) = (\xi^n, \sigma^n, set_n)
\end{cases}


\mathkw{match\_set} \overline{v} set = \begin{cases} true & set = @universal
true & set = @singleton w v1 \land \overline{v} = (v2) \land v1 = \mathkw{extract\_num} v2
false & set = @singleton w v1 \land \overline{v} = (v2) \land v1 \neq \mathkw{extract\_num} v2
true & set = v1 \texttt{\&\&\&} v2 \land \overline{v} = (v3) \land v1 \& v2 = v3 \& v2
false & set = v1 \texttt{\&\&\&} v2 \land \overline{v} = (v3) \land v1 \& v2 \neq v3 \& v2
true & set = v1 .. v2 \land \overline{v} = (v3) \land v1 \leq v3 \leq v2
false & set = v1 .. v2 \land \overline{v} = (v3) \land (v3 \lt v1 \lor v3 \gt v2)
\mathkw{match\_set} (v1) set_1 \&\& ... \&\& \mathkw{match\_set} (v_n) set_n & set = @product (set_1,...,set_n) \land \overline{v} = (v1,...,v_n)
\mathkw{match\_set} (v1) set_1 || ... || \mathkw{match\_set} (v_n) set_n & set = \mathkw{value\_set} \overline{matches} (set_1,...,set_n) \land \overline{v} = (v1,...,v_n)
\mathkw{match\_set} \overline{v} (v1 \texttt{\&\&\&} v2) & set = @lpm w v1 v2
\end{cases}
~

### Parser State machine
~ MathPre
\mathkw{transition\_select} \zeta \xi \sigma (@select (\overline{e}) \{\overline{matches:x}\}) = \begin{cases} (\xi'', \sigma'', None) & <\zeta, \xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \overline{v}> \land \mathkw{set\_of\_matches} \zeta \xi' \sigma' \overline{matches} (\mathkw{width\_of\_val} \overline{v}) = (\xi'', \sigma'', \overline{set}) \land \forall set_i \in \overline{set}, \mathkw{match\_set} \overline{v} set_i = false
(\xi'', \sigma'', Some\ x_i) & <\zeta, \xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \overline{v}> \land \mathkw{set\_of\_matches} \zeta \xi' \sigma' \overline{matches} (\mathkw{width\_of\_val} \overline{v}) = (\xi'', \sigma'', \overline{set}) \land \mathkw{match\_set} \overline{v} set_i = true \land \forall j \lt i, \mathkw{match\_set} \overline{v} set_j = false
\end{cases}


\mathkw{parser\_state\_machine} \zeta \xi \sigma \overline{state} (@state x \{\overline{s}; @transition state\_expr\}) = \begin{cases} (\xi', \sigma', \mathkw{sig\_continue}) & state\_expr = ``accept" \land <\zeta, \xi, \sigma, \{s1; ... s_n;\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}>
(\xi', \sigma', \mathkw{sig\_reject} ``NoError") & state\_expr = ``reject" \land <\zeta, \xi, \sigma, \{s1; ... s_n;\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}>
\mathkw{parser\_state\_machine} \zeta \xi' \sigma' \overline{state} (@state x_{next} \{...\}) & @state x_{next} \{...\} \in \overline{state} \land state\_expr = x_{next} \land x_{next} \neq ``accept" \land x_{next} \neq ``reject" \land <\zeta, \xi, \sigma, \{s1; ... s_n;\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}>
\mathkw{parser\_state\_machine} \zeta \xi'' \sigma'' \overline{state} (@state x \{\overline{s}; @transition x_{next}\}) & state\_expr = @select (\overline{e}) \{\overline{matches:x}\} \land <\zeta, \xi, \sigma, \{s1; ... s_n;\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}> \land \mathkw{transition\_select} \zeta \xi' \sigma' state\_expr = (\xi'', \sigma'', Some\ x_{next})
(\xi', \sigma', \mathkw{sig\_reject} ``NoMatch") & state\_expr = @select (\overline{e}) \{\overline{matches:x}\} \land <\zeta, \xi, \sigma, \{s1; ... s_n;\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}> \land \mathkw{transition\_select} \zeta \xi' \sigma' state\_expr = (\xi'', \sigma'', None)
\end{cases}
~

### LValue Evaluation
$e$ has type $\tau$.
~ MathPre
\mathkw{lv\_of\_expr} \zeta \xi \sigma e1 = \begin{cases} (\xi, \sigma, \mathkw{sig\_continue}, @lvalue t x) & e1 = x
(\xi', \sigma', sig, @lvalue t lv_o.name) & e1 = e2.name \land \mathkw{lv\_of\_expr} \zeta \xi \sigma e2 = (\xi', \sigma', sig, lv_o)
(\xi', \sigma', \mathkw{sig\_continue}, @lvalue t lv_o[n1:n2] ) & e1 = e2[n1:n2] \land \mathkw{lv\_of\_expr} \zeta \xi \sigma e2 = (\xi', \sigma', \mathkw{sig\_continue}, lv_o)
(\xi'', \sigma'', \mathkw{sig\_continue}, @lvalue t lv_o[v]) & e1 = e2[e3] \land \mathkw{lv\_of\_expr} \zeta \xi \sigma e2 = (\xi', \sigma', \mathkw{sig\_continue}, lv_o) \land <\zeta, \xi, \sigma, e3> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v>
\end{cases}

\mathkw{value\_of\_lv} \xi lv_1 = \begin{cases} \xi(x) & lv_1 = @lvalue t x
v & lv_1 = @lvalue t lv_2.name \land (\mathkw{value\_of\_lv} \xi lv_2 = @struct \{ \overline{(name, v)} \} \lor \mathkw{value\_of\_lv} \xi lv_2 = @header b \{ \overline{(name, v)} \} \lor \mathkw{value\_of\_lv} \xi lv_2 = \mathkw{header\ union} \{ \overline{(name, v)} \}) \land (x,v) \in \overline{(name,v)}
v_{n_{next}\%n_{size}} & lv_1 = @lvalue t lv_2.@next \land \mathkw{value\_of\_lv} \xi lv_2 = (\overline{v},n_{size},n_{next})
(@bitslice (\mathkw{extract\_num} (\mathkw{value\_of\_lv} \xi lv_2)) n1 n2)_u^{(n1-n2+1)} & lv_1 = @lvalue t lv_2[n1:n2]
v_{(\mathkw{extract\_num} v_{index})\%n_{size}} & lv_1 = @lvalue t lv_2[v_{index}] \land \mathkw{value\_of\_lv} \xi lv_2 = (\overline{v},n_{size},n_{next})
\end{cases}

\mathkw{assign\_lv} \, \xi \, \sigma \, lv_1 \, v = \begin{cases} (\sigma[v/(\xi(x))], \mathkw{sig\_continue}) &  lv_1 = @lvalue t x
\mathkw{assign\_lv} \, \xi \, \sigma \, lv_2 \, (@struct \{...,(name, v),...\}) & lv_1 = @lvalue t lv_2.name \land \mathkw{value\_of\_lv} \xi lv_2 = @struct \{ \overline{(name, v)} \}
\mathkw{assign\_lv} \, \xi \, \sigma \, lv_2 \, (@header true \{...,(name, v),...\}) & lv_1 = @lvalue t lv_2.name \land \mathkw{value\_of\_lv} \xi lv_2 = @header b \{ \overline{(name, v)} \}
\mathkw{assign\_lv} \, \xi \, \sigma \, lv_2 \, (\mathkw{header\ union} \{(name_i, @header false ...),...,(name, v)\}) & lv_1 = @lvalue t lv_2.name \land \mathkw{value\_of\_lv} \xi lv_2 = \mathkw{header\ union} \{ \overline{(name, v)} \} \land v = @header true \{...\}
\mathkw{assign\_lv} \, \xi \, \sigma \, lv_2 \, (\mathkw{header\ union} \{ \overline{(name, @header false ...)}\}) & lv_1 = @lvalue t lv_2.name \land \mathkw{value\_of\_lv} \xi lv_2 = \mathkw{header\ union} \{ \overline{(name, v)} \} \land v = @header false \{...\}
\mathkw{assign\_lv} \, \xi \, \sigma \, lv_2 \, (v_i,...,v_{n_{next}}:=v, n_{size}, n_{next}) & lv_1 = @lvalue t lv_2.@next \land \mathkw{value\_of\_lv} \xi lv_2 = (\overline{v}, n_{size}, n_{next})
\mathkw{assign\_lv} \, \xi \, \sigma \, lv_2 \, (v_i,...,v_{n_{next}-1}:=v, n_{size}, n_{next}) & lv_1 = @lvalue t lv_2.@last \land \mathkw{value\_of\_lv} \xi lv_2 = (\overline{v}, n_{size}, n_{next})
\mathkw{assign\_lv} \, \xi \, \sigma \, lv_2 \, (n[n1:n2]:=\mathkw{extract\_num} v)_u^w & lv_1 = @lvalue t lv_2[n1:n2] \land \mathkw{value\_of\_lv} \xi lv_2 = n_u^w
\mathkw{assign\_lv} \, \xi \, \sigma \, lv_2 \, (v_i,...,v_{index}:=v, n_{size}, n_{next}) & lv_1 = @lvalue t lv_2[v_{index}] \land \mathkw{value\_of\_lv} \xi lv_2 = (\overline{v}, n_{size}, n_{next}) \land 0 \leq \mathkw{extract\_num} v_{index} \lt n_{size}
(\xi, \mathkw{sig\_reject} ``StackOutOfBounds") & lv_1 = @lvalue t lv_2[v_{index}] \land \mathkw{value\_of\_lv} \xi lv_2 = (\overline{v}, n_{size}, n_{next}) \land (\mathkw{extract\_num} v_{index} \lt 0 \lor \mathkw{extract\_num} v_{index} \geq n_{size})
\end{cases}
~
If $v$ is a tuple or arbitrary-width integer, $v$ will be cast to type $\tau$ if $lv_1 = \mathkw{lvalue}\ \tau\ ...$.

### Default Action
~ MathPre
@default \overline{prop} = \begin{cases} x(\overline{e}) & \mathkw{default\_action} = x \in \overline{prop}
@NoAction() & \mathkw{default\_action} = x \not\in \overline{prop}
\end{cases}
~

### LPM Entries
$\mathkw{sort\_lpm}\ \overline{set}\ n$ is $\overline{set}$ with elements up
until the first occurrence of $\mathkw{universal}$, if one exists, sorted in descending order by $w$.
Elements can be of the form $\mathkw{universal}$, $\mathkw{lpm}\ w\ v_1\ v_2$, or
$\mathkw{product}\ \overline{set}'$. If an element $set_i = \mathkw{product}\ \overline{set}'$ then it
is replaced with $set'_n$ where $set'_n = \mathkw{lpm}\ w\ v_1\ v_2$ or $set'_n = \mathkw{universal}$.

$\mathkw{bits}\ n$ is the number of bits not masked by $n$.

~ MathPre
\mathkw{lpm\_set} set = \begin{cases} @universal & set = @universal
@lpm w v1 v2 & set = @lpm w v1 v2
@lpm w v_u^w (\texttt{\textasciitilde} v)_u^w & set = @singleton w v
@lpm (@bits (\mathkw{extract\_num} v2)) v1 v2 & set = v1 \texttt{\&\&\&} v2
@product (\mathkw{lpm\_set} \overline{set}) & set = @product \overline{set}
\end{cases}

\mathkw{lpm\_entries} \overline{set} \overline{x} \overline{v} = \begin{cases} (\mathkw{sort\_lpm} (\mathkw{lpm\_set} \overline{set}) n, \overline{v}) & \overline{x} = (@lpm)
(\mathkw{sort\_lpm} (\mathkw{lpm\_set} \overline{set}') i, (v_i)) & \overline{x} = (...,x_i = @lpm,...) \land \forall set \in \overline{set} \text{ where } \mathkw{match\_set} \overline{v} set = true, set \in \overline{set}'
(\overline{set}, \overline{v}) & @lpm \not\in \overline{x}
\end{cases}
~

### Initial Value of Type
~ MathPre
\mathkw{init\_val} \xi t_1 = \begin{cases} false & t_1 = @bool
``" & t_1 = @string
0 & t_1 = @int
0^w_u & t_1 = @bit<w>
0^w_s & t_1 = @int<w>
(w, 0^0_u) & t_1 = @varbit<w>
((\mathkw{init\_val} \xi t)^a, a, 0) & t_1 = t_2[a]
(\mathkw{init\_val} \xi \overline{t}) & t_1 = @tuple<\overline{t}>
(\mathkw{init\_val} \xi \overline{t}) & t_1 = \{ \overline{t} \}
\{\overline{f=\mathkw{init\_val} \xi t}\} & t_1 = \{ \overline{f:t} \}
@universal & t_1 = @set<t>
@error.@NoError & t_1 = @error
@matchkind @exact & t_1 = \mathkw{match\_kind}
\mathkw{init\_val} \xi (\xi(X)) & t_1 = X
\mathkw{init\_val} \xi (\xi(.X)) & t_1 = .X
\mathkw{init\_val} \xi t_2 & t_1 = @newtype X t_2
@None & t_1 = @void
@header false \{ \overline{f:\mathkw{init\_val} \xi t} \} & t_1 = @header \{ \overline{f:t} \}
\mathkw{header\ union} \{ \overline{f:\mathkw{init\_val} \xi t} \} & t_1 = \mathkw{header\ union} \{ \overline{f:t} \}
@struct \{ \overline{f:\mathkw{init\_val} \xi t} \} & t_1 = @struct \{ \overline{f:t} \}
X.x_1 & t_1 = @enum X \{ \overline{x} \}
(X.x_1, \mathkw{init\_val} \xi t_2)& t_1 = @enum t_2 X \{ \overline{x=v} \}
\end{cases}
~
$(\mathkw{init\_val} \xi t)^n$ is short for $n$ occurrences of $\mathkw{init\_val} \xi t$.

### Name of Type
~ MathPre
@nametype t_1 = \begin{cases} X & t_1 = X
X & t_1 = @newtype X t_2
X & t_1 = @enum X \{\overline{x}\}
@nametype t_2 & t_1 = t_2<\overline{t}>
\end{cases}
~

## Expression Evaluation

Expressions are evaluated according to the following big-step relation:
~ Center
$\langle \zeta, \xi, \sigma, e \rangle \Downarrow_e \langle \xi', \sigma', sig, v \rangle$
~

### Evaluation of Constants

~ Infer

-------------------------------------------------------------------------------[Bool-True]
<\zeta, \xi, \sigma, true> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, true>
~

~ Infer

-------------------------------------------------------------------------------[Bool-False]
<\zeta, \xi, \sigma, false> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, false>
~

~ Infer

-------------------------------------------------------------------------------[Int-Constant]
<\zeta, \xi, \sigma, a> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, a>
~

~ Infer

-------------------------------------------------------------------------------[Unsigned-Int-Constant]
<\zeta, \xi, \sigma, nwa> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, a_u^n>
~

~ Infer

-------------------------------------------------------------------------------[Signed-Int-Constant]
<\zeta, \xi, \sigma, nsa> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, a_s^n>
~

~ Infer

-------------------------------------------------------------------------------[String]
<\zeta, \xi, \sigma, u> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, u>
~

### Evaluation of Variables

~ Infer
x \neq @verify
-------------------------------------------------------------------------------[Var]
<\zeta, \xi, \sigma, x> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, (\sigma  \circ \xi)(x)>
~

~ Infer

-------------------------------------------------------------------------------[Var-Verify]
<\zeta, \xi, \sigma, @verify> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, @extern @verify @None>
~

~ Infer

-------------------------------------------------------------------------------[Var-Top]
<\zeta, \xi, \sigma, .x> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, (\sigma  \circ \xi)(.x)>
~

### Evaluation of Accessess

~ Infer
<\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\dots,v_{(\mathkw{extract\_num} v) \% n_{size}},\dots,n_{size},n_{next})>
<\zeta, \xi', \sigma', e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v>
-------------------------------------------------------------------------------[Array-Access]
<\zeta, \xi, \sigma, e_1[e_2]> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_{(\mathkw{extract\_num} v) \% n_{size}}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
-----------------------------------------------------------------------------------------------------------[Bitslice]
<\zeta, \xi, \sigma, e[n1:n2]> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (@bitslice (\mathkw{extract\_num} v))_u^{(n1-n2+1)}>
~

~ Infer
<\zeta, \xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', sig, \overline{v}>
-------------------------------------------------------------------------------[List-Expression]
<\zeta, \xi, \sigma, \{\overline{e}\}> \Downarrow_e <\xi', \sigma', sig, (\overline{v})>
~

~ Infer
<\zeta, \xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', sig, \overline{v}>
-------------------------------------------------------------------------------[Record]
<\zeta, \xi, \sigma, \{ \overline{name=e} \}> \Downarrow_e <\xi', \sigma', sig, \{ \overline{name=v} \}>
~

### Unary Operation Evaluation

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
\diamond \in \{ !, \texttt{\textasciitilde}, - \}
-------------------------------------------------------------------------------[Unary-Op]
<\zeta, \xi, \sigma, \diamond e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \diamond v>
~

### Binary Operation Evaluation

~ Infer
<\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1>
<\zeta, \xi', \sigma', e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2>
\diamond \in \{ +, |+|, -, |-|, *, /, \%, \ll, \gg, \lt, \gt, \leq, \geq, ==, !=, \&, \hat{}, |, ++, \&\&, || \}
-------------------------------------------------------------------------------[Binary-Op]
<\zeta, \xi, \sigma, e_1 \diamond e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_1 \diamond v_2>
~

### Evaluation of Casts
~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, 1_u^1>
-------------------------------------------------------------------------------[Bool-Cast-True]
<\zeta, \xi, \sigma, (@bool) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @true>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, n_u^1>
n \neq 1
-------------------------------------------------------------------------------[Bool-Cast-False]
<\zeta, \xi, \sigma, (@bool) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @false>
~

$\mathkw{of2s}(a)$ is the result of converting $a$ from two's complement while $\mathkw{to2s}(a)$ is the result of converting $a$ to two's complement.

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
-------------------------------------------------------------------------------------[Bit-Cast]
<\zeta, \xi, \sigma, (@bit<w>) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, {@of2s(\mathkw{extract\_num} v)}_u^{w}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
--------------------------------------------------------------------------------------[Int-Cast]
<\zeta, \xi, \sigma, (@int<w>) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, {@to2s(\mathkw{extract\_num} v)}_s^{w}>
~

~ Infer
<\zeta, \xi, \sigma, (\xi(X)) e> \Downarrow_e <\xi', \sigma', sig, v>
-------------------------------------------------------------------------------[TypeName-Cast]
<\zeta, \xi, \sigma, (X) e> \Downarrow_e <\xi', \sigma', sig, v>
~

~ Infer
<\zeta, \xi, \sigma, (t) e> \Downarrow_e <\xi', \sigma', sig, v>
-------------------------------------------------------------------------------[NewType-Cast]
<\zeta, \xi, \sigma, (@newtype X t) e> \Downarrow_e <\xi', \sigma', sig, v>
~

### Member Expression Evaluation

~ Infer
\xi(X_1) = @enum X_2 \{\dots,name,\dots\}
-------------------------------------------------------------------------------[Type-Member-Enum]
<\zeta, \xi, \sigma, X_1.name> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, X_2.name>
~

~ Infer
\xi(X_1) = @enum t X_2 \{\dots,(name, e),\dots\}
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
-------------------------------------------------------------------------------[Type-Member-SEnum]
<\zeta, \xi, \sigma, X_1.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (X_2.name, (t) v)>
~

~ Infer

-------------------------------------------------------------------------------[Error-Member]
<\zeta, \xi, \sigma, @error.name> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, @error.name>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @struct \{\dots,(name, v),\dots\}>
-------------------------------------------------------------------------------[Struct-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots,(name, v),\dots \}>
-------------------------------------------------------------------------------[Header-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots \}>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', \mathkw{sig\_continue}, lv_o)
-------------------------------------------------------------------------------[Header-IsValid-Field]
<\zeta, \xi, \sigma, e.@isValid> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, @builtin @isValid lv_o>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots \}>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', \mathkw{sig\_continue}, lv_o)
-------------------------------------------------------------------------------[Header-SetValid-Field]
<\zeta, \xi, \sigma, e.@setValid> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, @builtin @setValid lv_o>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots \}>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', \mathkw{sig\_continue}, lv_o)
-------------------------------------------------------------------------------[Header-SetInvalid-Field]
<\zeta, \xi, \sigma, e.@setInvalid> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, @builtin @setInvalid lv_o>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \mathkw{header\ union} \{ \dots,(name,v),\dots \}>
-------------------------------------------------------------------------------[Header-Union-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \mathkw{header\ union} \{ \dots \}>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', \mathkw{sig\_continue}, lv_o)
-------------------------------------------------------------------------------[Header-Union-IsValid-Field]
<\zeta, \xi, \sigma, e.@isValid> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, @builtin @isValid lv_o>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
-------------------------------------------------------------------------------[Array-Size-Field]
<\zeta, \xi, \sigma, e.@size> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, {n_{size}}_u^{32}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
n_{next} \lt n_{size}
-------------------------------------------------------------------------------[Array-Next-Field]
<\zeta, \xi, \sigma, e.@next> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_{n_{next}}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
n_{next} \geq n_{size}
-------------------------------------------------------------------------------[Array-Next-Field-OutOfBounds]
<\zeta, \xi, \sigma, e.@next> \Downarrow_e <\xi', \sigma', \mathkw{sig\_reject} ``StackOutOfBounds", @None>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
1 \leq n_{next} \leq n_{size}
-------------------------------------------------------------------------------[Array-Last-Field]
<\zeta, \xi, \sigma, e.@last> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_{n_{next} - 1}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
n_{next} \gt n_{size}
-------------------------------------------------------------------------------[Array-Last-Field-OutOfBounds-High]
<\zeta, \xi, \sigma, e.@last> \Downarrow_e <\xi', \sigma', \mathkw{sig\_reject} ``StackOutOfBounds", @None>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
n_{next} \lt 1
-------------------------------------------------------------------------------[Array-Last-Field-OutOfBounds-Low]
<\zeta, \xi, \sigma, e.@last> \Downarrow_e <\xi', \sigma', \mathkw{sig\_reject} ``StackOutOfBounds", @None>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
-------------------------------------------------------------------------------[Array-LastIndex-Field]
<\zeta, \xi, \sigma, e.@lastIndex> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (n_{next} - 1)_u^{32}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', sig, lv_o)
-------------------------------------------------------------------------------[Array-PopFront-Field]
<\zeta, \xi, \sigma, e.\mathkw{pop\_front}> \Downarrow_e <\xi'', \sigma'', sig, @builtin \mathkw{pop\_front} lv_o>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', sig, lv_o)
-------------------------------------------------------------------------------[Array-PushFront-Field]
<\zeta, \xi, \sigma, e.\mathkw{push\_front}> \Downarrow_e <\xi'', \sigma'', sig, @builtin \mathkw{push\_front} lv_o>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \{...;name=v;...\}>
--------------------------------------------------------------------------[Record-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (loc, name_{object})>
-------------------------------------------------------------------------------[Runtime-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @extern name (loc, name_{object})>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @parser \dots>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', sig, lv_o)
-------------------------------------------------------------------------------[Parser-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin name lv_o>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @control \dots>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', sig, lv_o)
-------------------------------------------------------------------------------[Control-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin name lv_o>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @table \dots>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', sig, lv_o)
-------------------------------------------------------------------------------[Table-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin name lv_o>
~


### Ternary Expression Evaluation

~ Infer
<\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', sig_1, @true>
<\zeta, \xi', \sigma', e_2> \Downarrow_e <\xi'', \sigma'', sig_2, v_2>
-------------------------------------------------------------------------------[Ternary-Op-True]
<\zeta, \xi, \sigma, e_1 ? e_2 : e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_2>
~

~ Infer
<\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', sig_1, @false>
<\zeta, \xi', \sigma', e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_3>
-------------------------------------------------------------------------------[Ternary-Op-False]
<\zeta, \xi, \sigma, e_1 ? e_2 : e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_3>
~

### Function Call Evaluation

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \xi_{closure} \otimes (\overline{x:t,d}) \to blk>
<\zeta, \xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin \, (@push \, \xi_{closure}) \, \sigma'' \, (\overline{x:t,d}) \, \overline{v} = \xi_{closure}',\sigma'''
<\zeta, \xi_{closure}', \sigma''', blk> \Downarrow_s <\xi_{closure}'', \sigma'''', \mathkw{sig\_return\ v}>
@copyout \, \zeta \, \xi'' \, \xi_{closure}'' \, \sigma'''' \, (\overline{x:t,d}) \, \overline{e} = \sigma'''''
-------------------------------------------------------------------------------[Function-Action]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi'', \sigma''''', \mathkw{sig\_continue}, v>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @isValid lv_o>
\mathkw{value\_of\_lv} \xi' lv_o = @header b \{\dots\}
----------------------------------------------------------------------------------------------[isValid-Header]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, b>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @isValid lv_o>
\mathkw{value\_of\_lv} \xi' lv_o = \mathkw{header\ union} \{ \dots,(name, @header true \{\dots\}), \dots\}
-------------------------------------------------------------------------------[isValid-Header-Union-True]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, true>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @isValid lv_o>
\mathkw{value\_of\_lv} \xi' lv_o = \mathkw{header\ union} \{ \overline{(name, @header false \{\dots\})}\}
-------------------------------------------------------------------------------[isValid-Header-Union-False]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, false>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @setValid lv_o>
\mathkw{value\_of\_lv} \xi' lv_o = @header b \{\overline{(name,v)}\}
\mathkw{assign\_lv} \xi' lv_o (@header true \{\overline{(name,v)}\}) = (\xi'',sig)
----------------------------------------------------------------------------------------------[setValid]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi'', \sigma', sig, true>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @setInvalid lv_o>
\mathkw{value\_of\_lv} \xi' lv_o = @header b \{\overline{(name,v)}\}
\mathkw{assign\_lv} \xi' lv_o (@header false \{\overline{(name,v)}\}) = (\xi'',sig)
----------------------------------------------------------------------------------------------[setInvalid]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi'', \sigma', sig, false>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin \mathkw{pop\_front} (@lvalue t[a] ...)>
<\zeta, \xi', \sigma', e> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v>
\mathkw{value\_of\_lv} \xi'' (@lvalue t[a] ...) = (\overline{v}, n_{size}, n_{next})
\mathkw{assign\_lv} \xi' (@lvalue t[a] ...) (v_{(\mathkw{extract\_num} v)+1},...,v_{n_size}, (\mathkw{init\_val} \xi'' t)^{\mathkw{extract\_num} v}, n_{size}, n_{next} - \mathkw{extract\_num} v) = (\xi''',sig)
--------------------------------------------------------------------------------------------------------[PopFront]
<\zeta, \xi, \sigma, f<\overline{t}>(e)> \Downarrow_e <\xi''', \sigma'', \mathkw{sig\_continue}, @None>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin \mathkw{push\_front} (@lvalue t[a] ...)>
<\zeta, \xi', \sigma', e> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v>
\mathkw{value\_of\_lv} \xi'' (@lvalue t[a] ...) = (\overline{v}, n_{size}, n_{next})
\mathkw{assign\_lv} \xi' (@lvalue t[a] ...) ((\mathkw{init\_val} \xi'' t)^{\mathkw{extract\_num} v},v1,...,v_{n_{size} - \mathkw{extract\_num} v}, n_{size}, n_{next} + \mathkw{extract\_num} v) = (\xi''',sig)
-------------------------------------------------------------------------------[PushFront]
<\zeta, \xi, \sigma, f<\overline{t}>(e)> \Downarrow_e <\xi''', \sigma'', \mathkw{sig\_continue}, @None>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @apply (@lvalue t x)>
\mathkw{value\_of\_lv} \xi' (@lvalue t x) = @parser (\overline{name,v}) (\overline{x:t,d}) \overline{decl} \overline{state}
<\zeta, \mathkw{set\_namespace} \xi' x, \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\zeta, \xi'''[\overline{v}/\overline{name}], \sigma'', \overline{decl}> \Downarrow_d <\xi'''', \sigma'''>
(@state ``start" \{...\}) \in \overline{state}
\mathkw{parser\_state\_machine} \zeta \xi'''' \sigma''' \overline{state} (@state ``start" \{...\}) = (\xi''''', \sigma'''', sig')
@copyout \zeta (@pop \xi''''') \xi''''' (\overline{x:t,d}) \overline{e} = \xi''''''
------------------------------------------------------------------------------[Apply-Parser]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\mathkw{set\_namespace} \xi'''''' (@namespace \xi'), \sigma'''', sig', @None>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @apply (@lvalue t x)>
\mathkw{value\_of\_lv} \xi' (@lvalue t x) = @control (\overline{name,v}) (\overline{x:t,d}) \overline{decl} blk
<\zeta, \mathkw{set\_namespace} \xi' x, \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\zeta, \xi'''[\overline{v}/\overline{name}], \sigma'', \overline{decl}> \Downarrow_d <\xi'''', \sigma'''>
<\zeta, \xi'''', \sigma''', blk> \Downarrow_s <\xi''''', \sigma'''', sig'>
@copyout \zeta (@pop \xi''''') \xi''''' (\overline{x:t,d}) \overline{e} = \xi''''''
------------------------------------------------------------------------------[Apply-Control]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\mathkw{set\_namespace} \xi'''''' (@namespace \xi'), \sigma'''', sig', @None>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @apply (@lvalue t x)>
\mathkw{value\_of\_lv} \xi' (@lvalue t x) = @table name \overline{e_k:x} \overline{action\_ref} x_{default}(\overline{e}_{default}) \{ \overline{matches:x(\overline{e})} \}
<\zeta, \mathkw{set\_namespace} \xi' x, \sigma', \overline{e}_k> \Downarrow_e <\xi'', \sigma'', sig ,\overline{v}>
\mathkw{set\_of\_matches} \zeta \xi'' \sigma'' \overline{matches'} (\mathkw{width\_of\_val} \overline{v}) = (\xi''', \sigma''', \overline{set})
\mathkw{lpm\_entries} \overline{set} \overline{x} \overline{v} = (\overline{set}',\overline{v}')
\forall i \text{where} 1 \leq i \leq n, \mathkw{match\_set} \overline{v}' set'_i = false
<\zeta, \xi''', \sigma''', x_{default}(\overline{e}_{default})> \Downarrow_e <\xi'''', \sigma'''', sig', v>
----------------------------------------------------------------------------------------------------------------------------[Apply-Table-Default]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi'''', \sigma'''', sig', \{(``\text{hit}",false);(``\text{action\_run}", name.x_{default})\}>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @apply (@lvalue t x)>
\mathkw{value\_of\_lv} \xi' (@lvalue t x) = @table name \overline{e_k:x} \overline{action\_ref} x_{default}(\overline{e}_{default}) \{ \overline{matches:x(\overline{e})} \}
<\zeta, \mathkw{set\_namespace} \xi' x, \sigma', \overline{e}_k> \Downarrow_e <\xi'', \sigma'', sig ,\overline{v}>
\mathkw{set\_of\_matches} \zeta \xi'' \sigma'' \overline{matches'} (\mathkw{width\_of\_val} \overline{v}) = (\xi''', \sigma''', \overline{set})
\mathkw{lpm\_entries} \overline{set} \overline{x} \overline{v} = (\overline{set}',\overline{v}')
\mathkw{match\_set} \overline{v} set'_i = true
\forall j \lt i, \mathkw{match\_set} \overline{v}' set'_j = false
<\zeta, \xi''', \sigma''', x_i(\overline{e}_i)> \Downarrow_e <\xi'''', \sigma'''', sig', v>
------------------------------------------------------------------------------[Apply-Table]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi'''', \sigma'''', sig', \{(``\text{hit}",true);(``\text{action\_run}", name.x_i)\}>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @extern name (loc, x)>
\xi'(x) = @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}
t name <\overline{X}>(\overline{x:t,d}) \in \overline{method}
@len \overline{x:t,d} = @len \overline{e}
<\zeta, \xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\zeta, \xi''', \sigma', \overline{t}, (((loc, x), @packet),(v1,t_1),...,(v_n, t_n))> \Downarrow_{T\_extern} <\xi'''', \sigma'', sig, v>
@copyout \zeta (@pop \xi'''') \xi'''' (\overline{x:t,d}) \overline{e} = \xi'''''
------------------------------------------------------------------------------[Extern-Function-Some-Caller]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi''''', \sigma'', sig, v>
~

$\mathkw{len}\ \overline{x}$ is defined as the number of elements in $\overline{x}$.
$\mathkw{packet}$ is a type name.
$\tau_i$ is the type of $e_i \in \overline{e}$

$\langle \zeta, \xi, \sigma, \overline{t}, (\overline{v,t}) \rangle \Downarrow_{Target\_extern} \langle \xi', \sigma', sig, v \rangle$ is a relation defined by the target.

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @extern name (loc, x)>
\xi'(x) = @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}
@abstract t name <\overline{X}>(\overline{x:t,d}) \in \overline{method}
@len \overline{x:t,d} = @len \overline{e}
<\zeta, \xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\zeta, \xi''', \sigma', \overline{t}, (((loc, x), @packet),(v1,t_1),...,(v_n, t_n))> \Downarrow_{T\_extern} <\xi'''', \sigma'', sig, v>
@copyout \zeta (@pop \xi'''') \xi'''' (\overline{x:t,d}) \overline{e} = \xi'''''
------------------------------------------------------------------------------[Extern-Function-Some-Caller-Abstract]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi''''', \sigma'', sig, v>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @extern name @None>
\xi'(name) = \mathkw{extern\ function} t x<\overline{X}>(\overline{x:t,d})
<\zeta, \xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\zeta, \xi''', \sigma', \overline{t}, (\overline{v,t})> \Downarrow_{T\_extern} <\xi'''', \sigma'', sig, v>
@copyout \zeta (@pop \xi'''') \xi'''' (\overline{x:t,d}) \overline{e} = \xi'''''
----------------------------------------------------------------------------------------------[Extern-Function-No-Caller]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi''''', \sigma'', sig, v>
~

### Nameless Instantiation Evaluation

~ Infer
\xi(@nametype t) = @control X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} @apply blk \}
<\zeta, \xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi') (\overline{x:t},@none) \overline{v} = \xi''
---------------------------------------------------------------------------------------[Control]
<\zeta, \xi, \sigma, t(\overline{e})> \Downarrow_e <@pop \xi'', \sigma', \mathkw{sig\_continue}, @control (\mathkw{first\_lvl} \xi'') (\overline{x:t,d}) \overline{decl} blk>
~

~ Infer
\xi(@nametype t) = @parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} \}
<\zeta, \xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi') (\overline{x:t},@none) \overline{v} = \xi''
-------------------------------------------------------------------------------[Parser]
<\zeta, \xi, \sigma, t(\overline{e})> \Downarrow_e <@pop \xi'', \sigma', \mathkw{sig\_continue}, @parser (\mathkw{first\_lvl} \xi'') (\overline{x:t,d}) \overline{decl} \overline{state}>
~

~ Infer
\xi(@nametype t) = @package<\overline{X}>(\overline{x:t,d})
<\zeta, \xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi') (\overline{x:t,d}) \overline{v} = \xi''
-------------------------------------------------------------------------------[Package]
<\zeta, \xi, \sigma, t(\overline{e})> \Downarrow_e <@pop \xi'', \sigma', \mathkw{sig\_continue}, @package (\mathkw{first\_lvl} \xi'')>
~

~ Infer
\xi(@nametype t) = @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}
(@namespace \xi, object) \in \sigma
-------------------------------------------------------------------------------[Extern-Object-Initialized]
<\zeta, \xi, \sigma, t(\overline{e})> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, (@namespace \xi, X)>
~

$(\mathkw{namespace} \xi, object) \in \sigma$ means if $\sigma = (packet, (\overline{name,object}))$ then $(\mathkw{namespace} \xi, object) \in (\overline{name,object})$.

~ Infer
\xi(@nametype t) = @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}
(@namespace \xi, object) \not\in \sigma
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @extern (@namespace \xi) ((@namespace \xi), X)>
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi'', \sigma'', sig, v>
-------------------------------------------------------------------------------[Extern-Object-Uninitialized]
<\zeta, \xi, \sigma, t(\overline{e})> \Downarrow_e <\xi'', \sigma'', sig, v>
~

### Set Operation Evaluation

~ Infer
<\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1>
<\zeta, \xi', \sigma, e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2>
-------------------------------------------------------------------------------[Masks]
<\zeta, \xi, \sigma, e_1 \texttt{\&\&\&} e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_1 \texttt{\&\&\&} v_2>
~

~ Infer
<\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1>
<\zeta, \xi', \sigma, e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2>
-------------------------------------------------------------------------------[Ranges]
<\zeta, \xi, \sigma, e_1 \mathbin{..} e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_1 \mathbin{..} v_2>
~

## Statements and Block Evaluation

Statements are evaluated according to the following big-step relation:
~ Center
$<\zeta, \xi, \sigma, s> \Downarrow_s <\xi', \sigma', sig>$
~

~ Infer
<\zeta, \xi, \sigma, e<\overline{t}>(\overline{e})> \Downarrow_e <\xi', \sigma', sig, v>
-----------------------------------------------------------------------------------------------[Method-Call]
<\zeta, \xi, \sigma, e<\overline{t}>(\overline{e})> \Downarrow_s <\xi', \sigma', sig>
~

~ Infer
<\zeta, \xi, \sigma, e_r> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
\mathkw{lv\_of\_expr} \zeta \xi \sigma' e_l = (\xi'', \sigma'', \mathkw{sig\_continue}, lv)
\mathkw{assign\_lv} \xi' \sigma'' lv v = (\sigma''', sig)
---------------------------------------------------------------------------[Assignment]
<\zeta, \xi, \sigma, e_l := e_r> \Downarrow_s <\xi', \sigma''', sig>
~

~ Infer
<\zeta, \xi, \sigma, t()> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @parser (\overline{name,v}) (\overline{x:t,d}) \overline{decl} \overline{state}>
<\zeta, \mathkw{set\_namespace} ((@namespace \xi') \char`\^ (@nametype t)) \xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\zeta, \xi'''[\overline{v}/\overline{name}], \sigma'', \overline{decl}> \Downarrow_d <\xi'''', \sigma'''>
(@state ``start" \{...\}) \in \overline{state}
\mathkw{parser\_state\_machine} \zeta \xi'''' \sigma''' \overline{state} (@state ``start" \{...\}) = (\xi''''', \sigma'''', sig)
@copyout \zeta (@pop \xi''''') \xi''''' (\overline{x:t,d}) \overline{e} = \xi''''''
--------------------------------------------------------------------------------------[Direct-Application-Parser]
<\zeta, \xi, \sigma, t.@apply (\overline{e})> \Downarrow_s <\mathkw{set\_namespace} (@namespace \xi') \xi'''''', \sigma'''', sig>
~

~ Infer
<\zeta, \xi, \sigma, t()> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @control (\overline{name,v}) (\overline{x:t,d}) \overline{decl} blk>
<\zeta, \mathkw{set\_namespace} ((@namespace \xi') \char`\^ (@nametype t)) \xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\zeta, \xi'''[\overline{v}/\overline{name}], \sigma'', \overline{decl}> \Downarrow_d <\xi'''', \sigma'''>
<\zeta, \xi'''', \sigma''', blk> \Downarrow_s <\xi''''', \sigma'''', sig>
@copyout \zeta (@pop \xi''''') \xi''''' (\overline{x:t,d}) \overline{e} = \xi''''''
--------------------------------------------------------------------------------------------[Direct-Application-Control]
<\zeta, \xi, \sigma, t.@apply (\overline{e})> \Downarrow_s <\mathkw{set\_namespace} (@namespace \xi') \xi'''''', \sigma'''', sig>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_reject\ v}, v>
------------------------------------------------------------------------------[Conditional-Reject]
<\zeta, \xi, \sigma, @if (e) s1 @else s2> \Downarrow_s <\xi', \sigma', \mathkw{sig\_reject\ v}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @true>
<\zeta, @push \xi', \sigma', s> \Downarrow_s <\xi'', \sigma'', sig>
------------------------------------------------------------------------------[If-True]
<\zeta, \xi, \sigma, @if (e) s> \Downarrow_s <\xi', \sigma'', sig>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @false>
------------------------------------------------------------------------------[If-False]
<\zeta, \xi, \sigma, @if (e) s> \Downarrow_s  <\xi', \sigma', \mathkw{sig\_continue}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @true>
<\zeta, @push \xi', \sigma', s_1> \Downarrow_s <\xi'', \sigma'', sig>
---------------------------------------------------------------------------------[If-Else-True]
<\zeta, \xi, \sigma, @if (e) s_1 @else s_2> \Downarrow_s <\xi', \sigma'', sig>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @false>
<\zeta, @push \xi', \sigma', s_2> \Downarrow_s <\xi'', \sigma'', sig>
---------------------------------------------------------------------------------[If-Else-False]
<\zeta, \xi, \sigma, @if (e) s_1 @else s_2> \Downarrow_s <\xi', \sigma'', sig>
~

~ Infer
<\zeta, @push \xi, \sigma, \overline{s}> \Downarrow_s <\xi', \sigma', sig>
--------------------------------------------------------------------------[Block]
<\zeta, \xi, \sigma, \{s_1; ... s_n;\}> \Downarrow_s <\xi, \sigma', sig>
~

~ Infer

---------------------------------------------------------------------[Exit-Continue]
<\zeta, \xi, \sigma, @exit> \Downarrow_s <\xi, \sigma, \mathkw{sig\_exit}>
~

~ Infer

---------------------------------------------[Empty]
<\zeta, \xi, \sigma, ;> \Downarrow_s <\xi, \sigma, sig>
~

~ Infer

---------------------------------------------[Return-Void]
<\zeta, \xi, \sigma, @return> \Downarrow_s <\xi, \sigma, \mathkw{sig\_return\ None}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
--------------------------------------------------------------------------[Return-Value]
<\zeta, \xi, \sigma, @return e> \Downarrow_s <\xi', \sigma', \mathkw{sig\_return\ v}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, name_1.name_2>
\mathkw{match\_switch\_case} \overline{case} name_2 = None
---------------------------------------------------------------------------------[Switch-No-Match]
<\zeta, \xi, \sigma, @switch (e) \{\overline{case}\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, name_1.name_2>
\mathkw{match\_switch\_case} \overline{case} name_2 = Some\ blk
<\zeta, @push \xi', \sigma', blk> \Downarrow_s <\xi'', \sigma'', sig>
---------------------------------------------------------------------------------[Switch-Match]
<\zeta, \xi, \sigma, @switch (e) \{\overline{case}\}> \Downarrow_s <\xi', \sigma'', sig>
~

~ Infer
<\zeta, \xi, \sigma, decl> \Downarrow_d <\xi', \sigma'>
--------------------------------------------------------------------[Declaration-Statement]
<\zeta, \xi, \sigma, decl> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}>
~

## Declaration Evaluation

Declarations are evaluated according to the following big-step relation:
~ Center
$\langle \zeta, \xi, \sigma, decl \rangle \Downarrow_d \langle \xi', \sigma' \rangle$
~

~ Infer

-------------------------------------------[Constant-Decl]
<\zeta, \xi, \sigma, @const t x:=v> \Downarrow_d <@new \, \xi \, \sigma \, x \, ((t) v)>
~

~ Infer
<\zeta, \mathkw{set\_namespace} ((@namespace \xi) \char`\^ x) \xi, \sigma, t(\overline{e})> \Downarrow_e <\xi', \sigma', sig, v>
-----------------------------------------------------------------------------------------------------------------[Instantiation-Decl]
<\zeta, \xi, \sigma, t x(\overline{e})> \Downarrow_d <@new \, (\mathkw{set\_namespace} (@namespace \xi) \xi') \, \sigma' \, x \, v>
~

~ Infer

-------------------------------------------[Parser-Decl]
<\zeta, \xi, \sigma, @parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} \}> \Downarrow_d <\xi[@parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} \}/X], \sigma>
~

~ Infer

-------------------------------------------[Control-Decl]
<\zeta, \xi, \sigma, @control X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} @apply blk \}> \Downarrow_d <\xi[@control X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} @apply blk \}/X], \sigma>
~

~ Infer
@new \, \xi \, \sigma \, x \, (\xi \otimes \overline{x:t,d}) \to blk) = \xi', \sigma'
-------------------------------------------------------------------------[Function-Decl]
<\zeta, \xi, \sigma, @function t x<\overline{X}>(\overline{x:t,d}) blk> \Downarrow_d <\xi'[ @function t x<\overline{X}>(\overline{x:t,d}) blk/x], \sigma'>
~

~ Infer
@new \, \xi \, \sigma \, x \, (@extern x @None) = \xi',\sigma'
---------------------------------------------------------------[Extern-Function-Decl]
<\zeta, \xi, \sigma, \mathkw{extern\ function} t x<\overline{X}>(\overline{x:t,d})> \Downarrow_d <(\xi'[\mathkw{extern\ function} t x<\overline{X}>(\overline{x:t,d})/x]), \sigma'>
~

~ Infer

-------------------------------------------[Variable-Decl]
<\zeta, \xi, \sigma, t x> \Downarrow_d <@new \, \xi \, \sigma \, x \, (\mathkw{init\_val})>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
--------------------------------------------------------------------------------[Variable-Initialized-Decl-Success]
<\zeta, \xi, \sigma, t x := e> \Downarrow_d <@new \, \xi' \, \sigma' \, x \, ((t) v)>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', sig, v>
sig \neq \mathkw{sig\_continue}
-------------------------------------------[Variable-Initialized-Decl-Fail]
<\zeta, \xi, \sigma, t x := e> \Downarrow_d <\xi', \sigma'>
~

~Infer
<\zeta, \xi[t/x], \sigma, e> \Downarrow <\xi', \sigma', sig\_continue, v>
------------------------------------------------------------------------------------------------[Value-Set-Decl-Success]
<\zeta, \xi, \sigma, \mathkw{value\_set}<t>(e) x> \Downarrow <@new \, \xi' \, \sigma' \, x \, v>
~

~Infer
<\zeta, \xi[t/x], \sigma, e> \Downarrow <\xi', \sigma', sig, v>
sig \neq \mathkw{sig\_continue}
--------------------------------------------------------------------------[Value-Set-Decl-Fail]
<\zeta, \xi, \sigma, \mathkw{value\_set}<t>(e) x> \Downarrow <\xi, \sigma>
~

~ Infer
@new \, \xi \, \sigma \, x \, (\xi \otimes (\overline{x:t,d_0},\overline{x:t}) \to blk) = \xi',\sigma'
------------------------------------------------------------------------------------------------------------[Action-Decl]
<\zeta, \xi, \sigma, @action x (\overline{x:t,d_0},\overline{x:t}) blk> \Downarrow_d <\xi'[@action x (\overline{x:t,d_0},\overline{x:t}) blk/x], \sigma'>
~

~ Infer
\mathkw{const\ entries} = \{ \overline{matches:action\_ref} \} \in \overline{prop}
\{ \overline{matches:action\_ref} \} \neq \{\}
@key = \{ \overline{e:x} \} \in \overline{prop}
@actions = \{ \overline{action\_ref} \} \in \overline{prop}
--------------------------------------------------------[Table-Decl-Constant-Entries]
<\zeta, \xi, \sigma, @table x \{ \overline{prop} \}> \Downarrow_d <@new \, (\xi[@table x \{ \overline{prop} \}/x]) \, \sigma \, x \, (@table x \overline{e} \overline{action\_ref} (@default \overline{prop}) \{ \overline{matches:action\_ref} \})>
~

~ Infer
\mathkw{const\ entries} = \{\} \in \overline{prop}
@key = \{ \overline{e:x} \} \in \overline{prop}
@actions = \{ \overline{action\_ref} \} \in \overline{prop}
--------------------------------------------------------[Table-Decl-Control-Plane-Entries]
<(\{ \overline{matches:action\_ref} \}, \overline{set}), \xi, \sigma, @table x \{ \overline{prop} \}> \Downarrow_d <@new \, (\xi[@table x \{ \overline{prop} \}/x]) \, \sigma \, x \, (@table x \overline{e} \overline{action\_ref} (@default \overline{prop}) \{ \overline{matches:action\_ref} \})>
~

~ Infer

-------------------------------------------[Header-Decl]
<\zeta, \xi, \sigma, @header X \{ \overline{x:t} \}> \Downarrow_d <\xi[@header X \{ \overline{x:t} \}/X], \sigma>
~

~ Infer

-------------------------------------------[Header-Union-Decl]
<\zeta, \xi, \sigma, \mathkw{header\ union} X \{ \overline{x:t} \}> \Downarrow_d <\xi[\mathkw{header\ union} X \{ \overline{x:t} \}/X], \sigma>
~

~ Infer

-------------------------------------------[Struct-Decl]
<\zeta, \xi, \sigma, @struct X \{ \overline{x:t} \}> \Downarrow_d <\xi[@struct X \{ \overline{x:t} \}/X], \sigma>
~

~ Infer

-------------------------------------------[Error-Decl]
<\zeta, \xi, \sigma, @error \{ \overline{x} \}> \Downarrow_d <\xi, \sigma>
~

~ Infer

-------------------------------------------[Matchkind-Decl]
<\zeta, \xi, \sigma, \mathkw{match\_kind} \{ \overline{x} \}> \Downarrow_d <\xi, \sigma>
~

~ Infer

-------------------------------------------[Enum-Decl]
<\zeta, \xi, \sigma, @enum X \{ \overline{x} \}> \Downarrow_d <\xi[@enum X \{ \overline{x} \}/X], \sigma>
~

~ Infer

-------------------------------------------[SEnum-Decl]
<\zeta, \xi, \sigma, @enum t X \{ \overline{x=e} \}> \Downarrow_d <\xi[@enum t X \{ \overline{x=e} \}/X], \sigma>
~

~ Infer

-------------------------------------------[Extern-Object-Decl]
<\zeta, \xi, \sigma, @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}> \Downarrow_d <\xi[@extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}/X], \sigma>
~

~ Infer

-------------------------------------------[Type-Def-Decl]
<\zeta, \xi, \sigma, @typedef t X> \Downarrow_d <\xi[@typedef t X/X], \sigma>
~

~ Infer

-------------------------------------------[New-Type-Decl]
<\zeta, \xi, \sigma, @type t X> \Downarrow_d <\xi[@type t X/X], \sigma>
~

~ Infer

-------------------------------------------[Control-Type-Decl]
<\zeta, \xi, \sigma, @control X<\overline{X}>(\overline{x:t,d})> \Downarrow_d <\xi[@control X<\overline{X}>(\overline{x:t,d})/X], \sigma>
~

~ Infer

-------------------------------------------[Parser-Type-Decl]
<\zeta, \xi, \sigma, @parser X<\overline{X}>(\overline{x:t,d})> \Downarrow_d <\xi[@parser X<\overline{X}>(\overline{x:t,d})/X], \sigma>
~

~ Infer

-------------------------------------------[Package-Type-Decl]
<\zeta, \xi, \sigma, @package X<\overline{X}>(\overline{x:t})> \Downarrow_d <\xi[@package X<\overline{X}>(\overline{x:t})/X], \sigma>
~

## Program Evaluation

$r ::= (packet', n_{out\_port}) | \mathkw{None}$

Programs are evaluated according to the following big-step relation:
~ Center
$\langle \zeta, \xi, \sigma, packet, n_{in\_port}, \overline{decl} \rangle \Downarrow \langle \sigma', r \rangle$
~

~ Infer
<\zeta, \xi, \sigma, \overline{decl}> \Downarrow_d <\xi', \sigma'>
<\xi', n_{in\_port}> \Downarrow_{Target\_init} <\xi''>
<\zeta, \xi'', \sigma', packet, TODO> \Downarrow_{Target\_pipeline} <\sigma'', \xi''', packet'>
\xi'''(``std\_meta") = @struct \{...,(``egress\_port",n_u^w),...\}
----------------------------------------------------------------------------------------[Some-Packet]
<\zeta, \xi, \sigma, packet, n_{in\_port}, \overline{decl}> \Downarrow <\sigma', (packet', n)>
~

~ Infer
<\zeta, \xi, \sigma, \overline{decl}> \Downarrow_d <\xi', \sigma'>
<\xi', n_{in\_port}> \Downarrow_{Target\_init} <\xi''>
<\zeta, \xi'', \sigma', packet, TODO> \Downarrow_{Target\_pipeline} <\sigma'', \xi''', @None>
----------------------------------------------------------------------------------------[No-Packet]
<\zeta, \xi, \sigma, packet, n_{in\_port}, \overline{decl}> \Downarrow <\sigma', @None>
~

$p ::= packet | \mathkw{None}$

These relations are defined by the target:
~ Center
$\langle \xi, n_{in\_port} \rangle \Downarrow_{Target\_init} \langle \xi' \rangle$

$\langle \zeta, \xi, \sigma, packet, TODO \rangle \Downarrow_{Target\_pipeline} \langle \sigma', \xi', p \rangle$
~

# Type Soundness

## Environment Entailment

In order to prove type soundness under big-step semantics, we must define a relation
~MathPre
\models \, \subseteq \, (S,D,G) \times (\xi,\sigma)
~
where
~MathPre
S,D,G \models \xi,\sigma
~
means that the typing context satisfies the evaluation environment.
Intuitively, a typing context satisfies an evaluation environment if all of the variables in the typing context have the same type as their respective values they map to in the evaluation environment.

This entailment relation is defined in terms of a sub-relation
~MathPre
S,D,G \models_{scope} \epsilon,\sigma
~
which is $\models$ per-scope.

Here is a formal definition:
~Infer

------------------[Entails-Empty-Scope]
S,D,G \models_{scope} [],\sigma
~

~Infer
S,D,(G,\gamma) \models_{scope} \epsilon,\sigma
G(x) = t,d
S,D,G |- \sigma(\ell) : t, d
---------------------------------------------[Entails-Variable-Scope]
S,D,G \models_{scope} \epsilon,(x=\ell),\sigma
~


~ Infer

----------------------[Entails-Empty-Environment]
S,D,G \models (P,[],D,\nu),\sigma
~


~Infer
S,D,G \models (P,E,D,\nu),\sigma
S,D,G \models_{scope} \epsilon,\sigma
--------------------------------------------[Entails-Environment]
S,D,G \models (P,(E,\epsilon),D,\nu),\sigma
~

### Lemma: Entailment is Contravariant with respect to State
~MathPre
L_0: \forall S,D,G,\xi,\sigma,\sigma',
\sigma \subseteq \sigma' \Rightarrow S,D,G \models \xi,\sigma \Rightarrow S,D,G \models \xi,\sigma'
~

### Lemma: $\mathkw{lv\_of\_expr}$ Sustains Entailment

TODO: need a good definition for this...

~MathPre
L_1: \forall S,D,G,\xi,\xi',\sigma,\sigma',\zeta,e,sig,t,lv,
S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : t,\_ \Rightarrow \mathkw{lv\_of\_expr} \zeta \xi \sigma e = (\xi', \sigma', sig, @lvalue t lv) \Rightarrow S,D,G \models \xi',\sigma' \wedge \sigma \subseteq \sigma' \wedge S,D,G |- lv : t,\_
~

#### Proof

TODO!

### The Necromancer $\Psi$: Constructing $\Gamma$ from $\xi_{closure}$

For function call expressions involving copyin and copyout, the type-preservation proof needs the typing context $\Gamma$ from the function's definition.
We need a way to reverse engineer $\Gamma$ from the closure environment $\xi_{closure}$.
Ergo, the need for a necromancer function:
~MathPre
\Psi : \Sigma \times \Delta \times \xi_{closure} \times \sigma  \mapsto \Gamma
~
$\Psi$ is defined as follows:
~Infer

-------------------------------------------------[Necromance-Empty-Scope]
\psi \, S \, D \, [] \, \sigma \mapsto_{scope} []
~
~Infer
\psi \, S \, D \, \epsilon \, \sigma \mapsto_{scope} \gamma
S \, D \, \gamma |- \sigma(\ell) : t, d
----------------------------------------------------------------------------------[Necromance-Scope]
\psi \, S \, D \, ((\epsilon,x=\ell),\nu) \, \sigma \mapsto_{scope} \gamma,(x:t,d)
~
~Infer

---------------------------------------------------[Necromance-Empty-Environment]
\Psi \, S \, D \, (P,[],D,\nu) \, \sigma \mapsto []
~
~Infer
\Psi \, S \, D \, (P,E,D,\nu) \sigma \mapsto G
\psi \, S \, D \, \epsilon \, \sigma \mapsto_{scope} \gamma
-------------------------------------------------------------------[Necromance-Environment]
\Psi \, S \, D \, (P,(E,\epsilon),D,\nu) \, \sigma \mapsto G,\gamma
~

#### Corollary: The Necromancer necromances an entailing Typing Context

~MathPre
C_0: \forall S,D,\xi,\sigma,G
\Psi \, S \, D \, \xi \, \sigma \mapsto G \Rightarrow S,D,G \models \xi,\sigma
~

##### Proof

TODO: By inspection on the definitions of $\models$ and $\Psi$.

### Lemma: Copyin Preserves Entailment
TODO: Is this the right definition?
~MathPre
L_2: \forall \xi_{closure},x,t,d,v,\xi_{closure}',S,D,G,D_{\Psi},G_{\Psi}\sigma,\sigma'
S,D,G |- v : t, d \Rightarrow @copyin \, \xi_{closure} \, \sigma (x:t,d) v = \xi_{closure}',\sigma' \Rightarrow S,D_{\Psi},G_{\Psi} \models \xi_{closure},\sigma \Rightarrow S,D_{\Psi},G_{\Psi}[x:t,d] \models \xi_{closure}',\sigma' \wedge \sigma \subseteq \sigma'
~

#### Proof

TODO!

### Lemma: Copyout Preserves Entailment

TODO: probably need a better definition for this...

~MathPre
L_3: \forall \zeta, \xi_{call}, \xi_{closure} \, \sigma, x, t, d, e, \sigma', S, D, G, D_{\Psi}, G_{\Psi}
S,D,G |- e : t,d \Rightarrow @copyout \, \zeta \, \xi_{call} \, \xi_{closure} \, \sigma \, (x:t,d) \, e = \sigma' \Rightarrow S,D,G \models \xi_{call},\sigma \Rightarrow S,D_{\Psi},G_{\Psi} \models \xi_{closure},\sigma \Rightarrow S,D,G \models \xi_{call},\sigma' \wedge \sigma \subseteq \sigma'
~

#### Proof

TODO!

### Lemma: Push Preserves Entailment
~MathPre
L_4: \forall S,D,G,\xi, \sigma,
S,D,G \models \xi,\sigma \Rightarrow S,D,G \models @push \xi,\sigma
~

#### Proof

TODO!

### Lemma: Pop Preserves Entailment
~MathPre
L_5: \forall S,D,G,\xi,\sigma,
S,D,G \models \xi,\sigma \Rightarrow S,D,G \models @pop \xi,\sigma
~

#### Proof

TODO!

### Lemma $\mathkw{assign\_lv}$ Sustains Entailment

Need better definition...

~MathPre
L_6: \forall S,D,G,\xi,\sigma,lv,v,\sigma',sig,
S,D,G |- v : t,d \Rightarrow S,D,G |- lv : t,d \Rightarrow \mathkw{assign\_lvalue} \, \xi \, \sigma \, lv \, v = \sigma',sig \Rightarrow S,D,G \models \xi,\sigma \Rightarrow S,D,G \models \xi,\sigma'
~

#### Proof

TODO!

### Lemmas: State is Monotonic

These are used to prove statement type preservation.

#### Expression Monotonicity
~MathPre
L_7:\forall \zeta,\xi,\sigma,e,\xi',\sigma',sig,v
\langle \zeta, \xi, \sigma, e \rangle \Downarrow_e \langle \xi', \sigma', sig, v \rangle \Rightarrow \sigma \subseteq \sigma'
~

##### Proof

TODO!

#### Corollary: $\mathkw{lv\_of\_expr}$ is Monotonic
~MathPre
C_1: \forall \xi,\xi',\sigma,\sigma',\zeta,e,sig,t,lv,
\mathkw{lv\_of\_expr} \zeta \xi \sigma e = (\xi', \sigma', sig, @lvalue t lv) \Rightarrow \sigma \subseteq \sigma'
~

##### Proof

TODO!

#### Corollary: Copyin is Monotonic
~MathPre
C_2: \xi_{closure}, \sigma, x, t, d, v, \xi_{closure}',\sigma',
@copyin \, \xi_{closure} \, \sigma (x:t,d) v = \xi_{closure}',\sigma' \Rightarrow \sigma \subseteq \sigma'
~

##### Proof

TODO!

#### Statement Monotonicity
~MathPre
L_8: \zeta,\xi,\sigma,s,\xi',\sigma',sig,
<\zeta, \xi, \sigma, s> \Downarrow_s <\xi', \sigma', sig> \Rightarrow \sigma \subseteq \sigma'
~

#### Proof


TODO!

### Lemma: Extending $\Delta$ Preserves Entailment

TODO: Is this valid?

~MathPre
L_9: \forall
S,D,G \models \xi,\sigma \Rightarrow S,D[X \to \rho],G \models \xi,\sigma
~

#### Proof:

TODO!

### Definition of Typing Judgment for Values
~MathPre
\vdash_v v : \tau
~
TODO: this is a stub.

## Type Soundness of Expressions

### Expression Type Preservation Theorem Statement
~ MathPre
\forall e,v,\tau,d,S,D,G,\zeta, \xi, \sigma, \xi', \sigma', sig,
S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : \tau,d \Rightarrow \langle \zeta, \xi, \sigma, e \rangle \Downarrow_e \langle \xi', \sigma', sig, v \rangle \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : \tau,d
~

### Expression Type Preservation Proof
Introducing variables
~MathPre
e,v,\tau,d,S,D,G,\zeta, \xi, \sigma, \xi', \sigma', sig
~
and assuming hypotheses
~MathPre
S,D,G \models \xi,\sigma
S,D,G |- e : \tau,d
\langle \zeta, \xi, \sigma, e \rangle \Downarrow_e \langle \xi', \sigma', sig, v \rangle
~
we wish to prove the goal
~MathPre
S,D,G \models \xi',\sigma' \wedge S,D,G |- v : \tau,d
~
We induct on the derivation of
~MathPre
\langle \zeta, \xi, \sigma, e \rangle \Downarrow_e \langle \xi', \sigma', sig, v \rangle
~
We assume freely $e$ is free-variable free.

#### Case Bool-True
We have hypotheses:
~MathPre
S,D,G \models \xi, \sigma
S,D,G |- @true : @bool, @none
<\zeta, \xi, \sigma, @true> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, @true>
~
We wish to prove subgoals:
~MathPre
S,D,G \models \xi,\sigma \wedge S,D,G |- @true : @bool, @none
~
Our subgoal is true by assumption.

#### Case Bool-False
We have hypotheses:
~MathPre
S,D,G \models \xi, \sigma
S,D,G |- @false : @bool, @none
<\zeta, \xi, \sigma, @false> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, @true>
~
We wish to prove subgoal:
~MathPre
S,D,G \models \xi, \sigma \wedge S,D,G |- @false : @bool, @none
~
Our subgoal is true by assumption.

#### Case Int-Constant
We have hypotheses:
~MathPre
S,D,G \models \xi, \sigma
S,D,G |- a : @int, @none
<\zeta, \xi, \sigma, a> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, a>
~
We wish to prove subgoal:
~MathPre
S,D,G \models \xi, \sigma \wedge S,D,G |- a : @int, @none
~
Our subgoal is true by assumption.

#### Case Unsigned-Int-Constant
We have hypotheses:
~MathPre
S,D,G \models \xi, \sigma
S,D,G |- nwa : @bit<a>, @none
<\zeta, \xi, \sigma, nwa> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, a_u^n>
~
We wish to prove subgoal:
~MathPre
S,D,G \models \xi, \sigma \wedge S,D,G |- nwa : @bit<a>, @none
~
Our subgoal is true by assumption.

#### Case Signed-Int-Constant
We have hypotheses:
~MathPre
S,D,G \models \xi
S,D,G |- nsa : @int<w>, @none
<\zeta, \xi, \sigma, nsa> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, a_s^n>
~
We wish to prove subgoal:
~MathPre
S,D,G \models \xi, \sigma \wedge S,D,G |- nsa : @int<w>, @none
~
Our subgoal is true by assumption.

#### Case String
We have hypotheses:
~MathPre
S,D,G \models \xi, \sigma
S,D,G |- u : @string, @none
<\zeta, \xi, \sigma, u> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, u>
~
We wish to prove subgoal:
~MathPre
S,D,G \models \xi, \sigma \wedge S,D,G |- u : @string, @none
~
Our subgoal is true by assumption.

#### Case Var
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- x : t, d
H_2: <\zeta, \xi, \sigma, x> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, (\sigma \circ \xi)(x)>
~
We wish to prove subgoals
~MathPre
SG_1: S,D,G \models \xi, \sigma
SG_2: S,D,G |- (\sigma \circ \xi)(x) : t, d
~
$SG_1$ is true by assumption.

By inversion on $H_0$ and our assumption of the absence of free variables we get hypothesis:
~MathPre
S,D,G |- (\sigma \circ \xi)(x) : t, d
~
And thus our subgoal $SG_2$ is true by assumption.

#### Case Var-Top
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- .x : t, d
H_2: <\zeta, \xi, \sigma, .x> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, (\sigma \circ \xi)(.x)>
~
We wish to prove subgoal:
~MathPre
SG_1: S,D,G \models \xi,\sigma
SG_2: S,D,G |- (\sigma \circ \xi)(x) : t, d
~
$SG_1$ is true by assumption $H_0$.

By inversion on $H_0$ and our assumption of the absence of free variables we get hypothesis:
~MathPre
S,D,G |- (\sigma \circ \xi)(.x) : t, d
~
And thus our subgoal $SG_2$ is true by assumption.

#### Case Array-Access
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- e_1[e_2] : t_1, d_1
H_2: <\zeta, \xi, \sigma, e1[e2]> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_{(\mathkw{extract\_num} v) \% n_{size}}>
~
and inductive hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : t_1[], d_1 \Rightarrow <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\dots,v_{(\mathkw{extract\_num} v) \% n_{size}},\dots,n_{size},n_{next})> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- (\dots,v_{(\mathkw{extract\_num} v) \% n_{size}},\dots,n_{size},n_{next}) : t_1[], d_1
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2  : t_2, d_2 \Rightarrow <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi'',sigma'' \wedge S,D,G |- v  : t_2, d_2
~

We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_{(\mathkw{extract\_num} v) \% n_{size}} : t_1, d_1
~

By inversion on $H_1$ we get hypotheses:
~MathPre
H_3: S,D,G |- e_1 : t_1[], d_1
H_4: S,D,G |- e_2  : t_2, d_2
H_5: @numeric(t_2)
~

By inversion on $H_2$ we get hypotheses:
~MathPre
H_6: <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\dots,v_{(\mathkw{extract\_num} v) \% n_{size}},\dots,n_{size},n_{next})>
H_7: <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v>
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- (\dots,v_{(\mathkw{extract\_num} v) \% n_{size}},\dots,n_{size},n_{next}) : t_1[], d_1
~

Sketchy: By inversion on $H_9$ we may conclude $SG_2$.

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'', \sigma''
H_{11}: S,D,G |- v  : t_2, d_2
~
thus by assumption $H_{10}$ subgoal $SG_1$ is proven.

#### Case Bitslice
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- e[n_1:n_2] : S,D,G |- e1[e_2:e_3] : bit<n_1 - n_2 + 1>, d
H_2: <\zeta, \xi, \sigma, e[n_1:n_2]> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (@bitslice (\mathkw{extract\_num} v))_u^{(n1-n2+1)}>
~
and inductive hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : @bit<w>, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : @bit<w>, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi', \sigma'
SG_2: S,D,G |- (@bitslice (\mathkw{extract\_num} v))_u^{(n1-n2+1)} : bit<n1 - n2 + 1>, d
~

By inversion on $H_1$ and $H_2$ respectively we get hypotheses:
~MathPre
H_3: S,D,G |- e : @bit<w>, d
H_4:  <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~

Via the application $I_1 \, H_0 \, H_3 \, H_4$ we get hypotheses:
~MathPre
H_5: S,D,G \models \xi', \sigma'
H_6: S,D,G |- v : @bit<w>, d
~
By $H_5$, subgoal $SG_1$ holds.

Sketchy: By $H_6$ we know $v$ is numeric and thus $SG_2$ holds.

#### Case List-Expression
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- \{ \overline{e} \} : \{ \overline{\tau} \}, none
H_2: <\zeta, \xi, \sigma, \{\overline{e}\}> \Downarrow_e <\xi', \sigma', sig, (\overline{v})>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi, \sigma \Rightarrow S,D,G |- \overline{e: \tau, none} \Rightarrow <\zeta, \xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', sig, \overline{v}> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- \overline{v: \tau, none}
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi', \sigma'
SG_2: S,D,G |- \{ \overline{v} \} : \{ \overline{\tau} \}, none
~
By inversion on $H_1$ and $H_2$ we respectively get hypotheses:
~MathPre
H_3: S,D,G |- \overline{e: \tau, none}
H_4: <\zeta, \xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', sig, \overline{v}>
~

Via the application $I_1 \, H_0 \, H_3 \, H_4$ we get hypotheses:
~MathPre
H_5: S,D,G \models \xi', \sigma'
H_6: S,D,G |- \overline{v: \tau, none}
~
By $H_5$, subgoal $SG_1$ holds.

By constructing the rule-instance:
~ Infer
S,D,G |- \overline{v: \tau, none}
-----------------------------------------------[List-Expression]
S,D,G |- \{ \overline{v} \} : \{ \overline{\tau} \}, none
~
we prove subgoal $SG_2$.

#### Case Unary-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- \diamond e : t, d
H_2: <\zeta, \xi, \sigma, \diamond e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \diamond v>
~
and inductive hypothesis:
~MathPre
I_1: S,D,G \models \xi, \sigma \Rightarrow S,D,G |- e : t, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : t, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- \diamond v : t, d
~

By inversion on $H_1$ and $H_2$ we get the following subcases:

##### Subcase Not
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- !e : @bool, d
H_2: <\zeta, \xi, \sigma, !e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, !v>
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : @bool, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : @bool, d
H_3: S,D,G |- e : @bool, d
H_4: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- !v : @bool, d
~
Via the application $I_1 \, H_0 \, H_3 \, H_4$ we get hypotheses:
~MathPre
H_5: S,D,G \models \xi', \sigma'
H_6: S,D,G |- v : @bool, d
~
By $H_5$, subgoal $SG_1$ is proven.

By constructing the rule-instance:
~ Infer
S,D,G |- v : @bool, d
----------------------[Not]
S,D,G |- !v : @bool, d
~
we prove subgoal $SG_2$.

##### Subcase Bitwise-Not
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- {\texttt{\textasciitilde}e} : @bit<w>, d
H_2: <\zeta, \xi, \sigma, !e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, !v>
I_1: S,D,G \models \xi, \sigma \Rightarrow S,D,G |- e : @bit<w>, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi', \sigma' \wedge S,D,G |- v : @bit<w>, d
H_3: S,D,G |- e : @bit<w>, d
H_4: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi', \sigma'
SG_2: S,D,G |- {\texttt{\textasciitilde}v} : @bit<w>, d
~
Via the application $I_1 \, H_0 \, H_3 \, H_4$ we get hypotheses:
~MathPre
H_5: S,D,G \models \xi', \sigma'
H_6: S,D,G |- v : @bit<w>, d
~
By $H_5$, subgoal $SG_1$ is proven.

By constructing the rule-instance:
~ Infer
S,D,G |- v : @bit<w>, d
-------------------------------------------------[Bitwise-Not]
S,D,G |- {\texttt{\textasciitilde}v} : @bit<w>, d
~
we prove subgoal $SG_2$.

##### Subcase Negate
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- -e : t, d
H_2: <\zeta, \xi, \sigma, !e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, !v>
I_1: S,D,G \models \xi, \sigma \Rightarrow S,D,G |- e : t, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi', \sigma' \wedge S,D,G |- v : t, d
H_3: S,D,G |- e : t, d
H_7: @numeric(t)
H_4: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi', \sigma'
SG_2: S,D,G |- -v : t, d
~
Via the application $I_1 \, H_0 \, H_3 \, H_4$ we get hypotheses:
~MathPre
H_5: S,D,G \models \xi', \sigma'
H_6: S,D,G |- v : t, d
~
By $H_5$, subgoal $SG_1$ is proven.

By constructing the rule-instance:
~ Infer
S,D,G |- v : t, d
@numeric(t)
----------------------[Negate]
S,D,G |- -v : t, d
~
we prove subgoal $SG_2$.

#### Case Binary-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : t, @binaryDir(d_1, d_2)
H_2: <\zeta, \xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi, \sigma \Rightarrow S,D,G |- e_1 : t_1, d_1 \Rightarrow <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : t_1, d_1
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : t_2, d_2 \Rightarrow <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : t_2, d_2
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : t, @binaryDir(d_1, d_2)
~

By inversion on $H_1$ and $H_2$ we get the following subcases:

##### Subcase Bool-Binary-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : @bool, @binaryDir(d_1, d_2)
H_2: <\zeta, \xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : @bool, d_1 \Rightarrow <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : @bool, d_1
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : @bool, d_2 \Rightarrow <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : @bool, d_2
H_3: S,D,G |- e_1 : @bool, d_1
H_4: S,D,G |- e_2 : @bool, d_2
H_5: \diamond \in \{ \&\&, || \}
H_6: <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : @bool, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- v_1 : @bool, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'',\sigma''
H_{11}: S,D,G |- v_2 : @bool, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : @bool, d_1
S,D,G |- v_2 : @bool, d_2
\diamond \in \{ \&\&, || \}
------------------------------------------------------------------[Bool-Binary-Op]
S,D,G |- v_1 \mathbin{\diamond} v_2 : @bool, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

##### Subcase Int-Binary-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : @int, @binaryDir(d_1, d_2)
H_2: <\zeta, \xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : @int, d_1 \Rightarrow <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : @int, d_1
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : @int, d_2 \Rightarrow <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : @int, d_2
H_3: S,D,G |- e_1 : @int, d_1
H_4: S,D,G |- e_2 : @int, d_2
H_5: \diamond \in \{ +,-,*,<,>,\leq,\geq, /, \% \}
H_6: <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : @int, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- v_1 : @int, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'',\sigma''
H_{11}: S,D,G |- v_2 : @int, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : @int, d_1
S,D,G |- v_2 : @int, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq, /, \% \}
------------------------------------------------------------------[Int-Binary-Op]
S,D,G |- v_1 \mathbin{\diamond} v_2 : @int, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

##### Subcase Int-Signed-Binary-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi, \sigma
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : @int<w>, @binaryDir(d_1, d_2)
H_2: <\zeta, \xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : @int<w>, d_1 \Rightarrow <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : @int<w>, d_1
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : @int<w>, d_2 \Rightarrow <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : @int<w>, d_2
H_3: S,D,G |- e_1 : @int<w>, d_1
H_4: S,D,G |- e_2 : @int<w>, d_2
H_5: \diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-| \}
H_6: <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : @int<w>, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- v_1 : @int<w>, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'',\sigma''
H_{11}: S,D,G |- v_2 : @int<w>, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : @int<w>, d_1
S,D,G |- v_2 : @int<w>, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-| \}
------------------------------------------------------------------[Int-Signed-Binary-Op]
S,D,G |- v_1 \mathbin{\diamond} v_2 : @int<w>, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

##### Subcase Int-Unsigned-Binary-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : @bit<w>, @binaryDir(d_1, d_2)
H_2: <\zeta, \xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : @bit<w>, d_1 \Rightarrow <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : @bit<w>, d_1
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : @bit<w>, d_2 \Rightarrow <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : @bit<w>, d_2
H_3: S,D,G |- e_1 : @bit<w>, d_1
H_4: S,D,G |- e_2 : @bit<w>, d_2
H_5: \diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-|,\&,\hat{},|,\oplus \}
H_6: <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : @bit<w>, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- v_1 : @bit<w>, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'',\sigma''
H_{11}: S,D,G |- v_2 : @bit<w>, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : @bit<w>, d_1
S,D,G |- v_2 : @bit<w>, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-|,\&,\hat{},|,\oplus \}
------------------------------------------------------------------[Int-Unsigned-Binary-Op]
S,D,G |- v_1 \mathbin{\diamond} v_2 : @bit<w>, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

##### Subcase Equality-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : @bool, @binaryDir(d_1, d_2)
H_2: <\zeta, \xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : t, d_1 \Rightarrow <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : t, d_1
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : t, d_2 \Rightarrow <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : t, d_2
H_3: S,D,G |- e_1 : t, d_1
H_4: S,D,G |- e_2 : t, d_2
H_{12}: \mathkw{has\_equality}(t)
H_5: \diamond \in \{ ==,!= \}
H_6: <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : @bool, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- v_1 : t, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'',\sigma''
H_{11}: S,D,G |- v_2 : t, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : t, d_1
S,D,G |- v_2 : t, d_2
\diamond \in \{ ==,!= \}
------------------------------------------------------------------[Equality-Op]
S,D,G |- v_1 \mathbin{\diamond} v_2 : @bool, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

##### Subcase Bit-Concat-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e_1 \mathbin{++} e_2 : @bit<l+r>, @binaryDir(d_1, d_2)
H_2: <\zeta, \xi, \sigma, e1 \mathbin{++} e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \mathbin{++} v2>
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : @bit<l>, d_1 \Rightarrow <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : @bit<l>, d_1
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : @bit<r>, d_2 \Rightarrow <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : @bit<r>, d_2
H_3: S,D,G |- e_1 : @bit<l>, d_1
H_4: S,D,G |- e_2 : @bit<r>, d_2
H_6: <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_1 \mathbin{++} v_2 : @bit<l+r>, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- v_1 : @bit<l>, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'',\sigma''
H_{11}: S,D,G |- v_2 : @bit<r>, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : @bit<l>, d_1
S,D,G |- v_2 : @bit<r>, d_2
------------------------------------------------------------------[Bit-Concat-Op]
S,D,G |- v_1 \mathbin{++} v_2 : @bit<l+r>, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

##### Subcase Shift-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : t_1, @binaryDir(d_1, d_2)
H_2: <\zeta, \xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : t_1, d_1 \Rightarrow <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : t_1, d_1
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : t_2, d_2 \Rightarrow <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : t_2, d_2
H_3: S,D,G |- e_1 : t_1, d_1
H_4: S,D,G |- e_2 : t_2, d_2
H_{12}: @numeric(t_1)
H_{13}: t_2 = @bit<\_> \lor t_2 = @int
H_5: \diamond \in \{\ll, \gg\}
H_6: <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : @bit<l+r>, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- v_1 : t_1, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'',\sigma''
H_{11}: S,D,G |- v_2 : t_2, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : t_1, d_1
S,D,G |- v_2 : t_2, d_2
@numeric(t_1)
t_2 = @bit<\_> \lor t_2 = @int
\diamond \in \{\ll, \gg\}
------------------------------------------------------------------[Shift-Op]
S,D,G |- v_1 \mathbin{\diamond} v_2 : t_1, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

#### Case Bool-Cast-True
We have hypotheses:
~ MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- (@bool) e : @bool, @none
H_2: <\zeta, \xi, \sigma, (@bool) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @true>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : t_0, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, 1_u^1> \Rightarrow S,D,G \models \xi',\sigma' \wedge \Rightarrow S,D,G |- 1_u^1 : t_0, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- @true : @bool, @none
~

$SG_2$ is true by constructing rule-instance:
~ Infer

------------------------[Bool-True]
 S,D,G |- @true : @bool, @none
~

By inversion on $H_1$ we get hypotheses:
~MathPre
H_3: S,D,G |- e : t_0, d
H_4: t_0 \prec @bool
~

By inversion on $H_2$ we get hypothesis:
~MathPre
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, 1_u^1>
~

Via the application $I_1 \, H_0 \, H_3 \, H_5$ we get hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- 1_u^1 : t_0, d
~
By $H_6$ we prove subgoal $SG_1$.

#### Case Bool-Cast-False
We have hypotheses:
~ MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- (@bool) e : @bool, @none
H_2: <\zeta, \xi, \sigma, (@bool) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @false>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : t_0, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, n_u^1> \Rightarrow S,D,G \models \xi',\sigma' \wedge \Rightarrow S,D,G |- n_u^1 : t_0, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- @false : @bool, @none
~

$SG_2$ is true by constructing rule-instance:
~ Infer

------------------------[Bool-False]
 S,D,G |- @false : @bool, @none
~

By inversion on $H_1$ we get hypotheses:
~MathPre
H_3: S,D,G |- e : t_0, d
H_4: t_0 \prec @bool
~

By inversion on $H_2$ we get hypothesis:
~MathPre
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, n_u^1>
~

Via the application $I_1 \, H_0 \, H_3 \, H_5$ we get hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- n_u^1 : t_0, d
~
By $H_6$ we prove subgoal $SG_1$.

#### Case Bit-Cast
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- (@bit<w>) e : @bit<w>, @none
H_2: <\zeta, \xi, \sigma, (@bit<w>) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, {@of2s(\mathkw{extract\_num} v)}_u^{w}>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : t_0, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : t_0, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- {@of2s(\mathkw{extract\_num} v)}_u^{w} : @bit<w>, @none
~

TODO: maybe we need different typing rules for fixed sized ints?

#### Case TypeName-Cast
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- (X) e : X, @none
H_2: <\zeta, \xi, \sigma, (X) e> \Downarrow_e <\xi', \sigma', sig, v>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- (\xi(X)) e : \xi(X), @none \Rightarrow <\zeta, \xi, \sigma, (\xi(X)) e> \Downarrow_e <\xi', \sigma', sig, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : \xi(X), @none
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- v : X, @none
~
By inversion on $H_1$ and $H_2$ we have hypotheses:
~MathPre
H_3: S,D,G |- (\xi(X)) e : \xi(X), @none
H_4: \xi(X) \prec X
H_5: <\zeta, \xi, \sigma, (\xi(X)) e> \Downarrow_e <\xi', \sigma', sig, v>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we get hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- v : \xi(X), @none
~
By $H_6$, we prove $SG_1$.

Sketchy: By constructing the rule-instance:
~ Infer
S,D,G |- v : \xi(X), d
\xi(X) \prec X
-------------------------[Cast]
S,D,G |- (X) v : X, @none
~
~Infer

-----------------------[]
S,D,G |- v : X, @none
~
we prove subgoal $SG_2$

#### Case NewType-Cast
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- (@newtype X t) e : @newtype X t, @none
H_2: <\zeta, \xi, \sigma, (@newtype X t) e> \Downarrow_e <\xi', \sigma', sig, v>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- (t) e : t, @none \Rightarrow <\zeta, \xi, \sigma, (t) e> \Downarrow_e <\xi', \sigma', sig, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : t, @none
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- v : @newtype X t, @none
~
By inversion on $H_1$ and $H_2$ we have hypotheses:
~MathPre
H_3: S,D,G |- (t) e : t, d
H_4: t \prec (@newtype X t)
H_5: <\zeta, \xi, \sigma, (t) e> \Downarrow_e <\xi', \sigma', sig, v>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we get hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- v : t, @none
~
By $H_6$, we prove $SG_1$.

Sketchy: By constructing the rule-instance:
~ Infer
S,D,G |- v : t, @none
t \prec (@newtype X t)
-------------------------[Cast]
S,D,G |- (@newtype X t) v : @newtype X t, @none
~
~Infer

--------------------------------[]
S,D,G |- v : @newtype X t, @none
~
we prove subgoal $SG_2$

#### Case Type-Member-Enum
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- X_1.name : X_1, @none
H_2: <\zeta, \xi, \sigma, X_1.name> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, X_2.name>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi,\sigma
SG_2: S,D,G |-  X_2.name : X_1, @none
~
$SG_1$ is proven by $H_0$.

By inversion on $H_2$ we get hypothesis:
~MathPre
H_3: \xi(X_1) = @enum X_2 \{\dots,name,\dots\}
~
Thus $X_2$ can be substituted for $X_1$ under $\xi$. Thus $SG_2$ is proven by $H_1$.


#### Case Type-Member-SEnum
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |-  X_1.name : X_1, @none
H_2: <\zeta, \xi, \sigma, X_1.name> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, X_2.name>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi,\sigma
SG_2: S,D,G |-  X_2.name : X_1, @none
~
$SG_1$ is proven by $H_0$.

By inversion on $H_2$ we get hypothesis:
~MathPre
H_3: \xi(X_1) = @enum t X_2 \{\dots,(name, e),\dots\}
~
Thus $X_2$ can be substituted for $X_1$ under $\xi$. Thus $SG_2$ is proven by $H_1$.

#### Case Error-Member
We have hypotheses:
~ MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- @error.name : @error, @none
H_2: <\zeta, \xi, \sigma, @error.name> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, @error.name>
~
Our subgoal:
~MathPre
S,D,G \models \xi,\sigma \wedge S,D,G |- @error.name : @error, @none
~
is true by our assumptions $H_0 \wedge H_1$.

#### Case Struct-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e.name : t_{name}, @none
H_2: <\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow  S,D,G |- e : @struct \{f_1:t_1, \dots, f_n:t_n\}, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @struct \{\dots,(name, v),\dots\}> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- @struct \{\dots,(name, v),\dots\} : @struct \{f_1:t_1, \dots, f_n:t_n\}, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- v : t_{name}, @none
~
By inversion on $H_1$ and $H_2$ we get hypotheses:
~MathPre
H_3: S,D,G |- e : @struct \{f_1:t_1, \dots, f_n:t_n\}, d
H_4: \mathkw{has\_field} (@struct \{f_1:t_1, \dots, f_n:t_n\}) name t_{name}
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @struct \{\dots,(name, v),\dots\}>
~

Via the application $I_1 \, H_0 \, H_3 \, H_5$ we procure hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- @struct \{\dots,(name, v),\dots\} : @struct \{f_1:t_1, \dots, f_n:t_n\}
~
By $H_6$, we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- @struct \{\dots,(name, v),\dots\} : @struct \{f_1:t_1, \dots, f_n:t_n\}, d
\mathkw{has\_field} (@struct \{f_1:t_1, \dots, f_n:t_n\}) name t_{name}
-------------------------------------------------------------------[Expression-Member]
S,D,G |- v : t_{name}, @none
~
we prove subgoal $SG_2$.

#### Case Header-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e.name : t_{name}, @none
H_2: <\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow  S,D,G |- e : @header \{f_1:t_1, \dots, f_n:t_n\}, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots,(name, v),\dots \}> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- @header b \{ \dots,(name, v),\dots \} : @header \{f_1:t_1, \dots, f_n:t_n\}, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- v : t_{name}, @none
~
By inversion on $H_1$ and $H_2$ we get hypotheses:
~MathPre
H_3: S,D,G |- e : @header \{f_1:t_1, \dots, f_n:t_n\}, d
H_4: \mathkw{has\_field} (@header \{f_1:t_1, \dots, f_n:t_n\}) name t_{name}
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots,(name, v),\dots \}>
~

Via the application $I_1 \, H_0 \, H_3 \, H_5$ we procure hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- @header b \{ \dots,(name, v),\dots \} : @header \{f_1:t_1, \dots, f_n:t_n\}, d
~
By $H_6$, we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- @header b \{ \dots,(name, v),\dots \} : @header \{f_1:t_1, \dots, f_n:t_n\}, d
\mathkw{has\_field} (@header \{f_1:t_1, \dots, f_n:t_n\}) name t_{name}
------------------------------------------------------------------[Expression-Member]
S,D,G |- v : t_{name}, @none
~
we prove subgoal $SG_2$.

#### Case Header-IsValid-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e.@isValid : @bool
H_2: <\zeta, \xi, \sigma, e.@isValid> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, @builtin @isValid lv_o>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow  S,D,G |- e : @header \{f_1:t_1, \dots, f_n:t_n\}, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots,(name, v),\dots \}> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- @header b \{ \dots,(name, v),\dots \} : @header \{f_1:t_1, \dots, f_n:t_n\}, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- @builtin @isValid lv_o : @bool
~
By inversion on $H_1$ and $H_2$ we obtain hypotheses:
~MathPre
H_3: S,D,G |- e : @header \{f_1:t_1, \dots, f_n:t_n\}, d
H_4: \mathkw{has\_field} (@header \{f_1:t_1, ... , f_n:t_n\}) @isValid (() -> @bool)
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots \}>
H_6: \mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', \mathkw{sig\_continue}, lv_o)
~
Via application $I_1 \, H_0 \, H_3 \, H_5$ we acquire hypotheses:
~MathPre
H_7: S,D,G \models \xi',\sigma'
H_8: S,D,G |- @header b \{ \dots,(name, v),\dots \} : @header \{f_1:t_1, \dots, f_n:t_n\}, d
~
Via application $L_1 \, H_6 \, H_7$ we get hypothesis:
~MathPre
H_9: S,D,G \models \xi'',\sigma''
~
which proves subgoal $SG_1$.

TODO: I'm confused about these cases...

#### Case Header-Union-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e.name : t_{name}, @none
H_2: <\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow  S,D,G |- e : \mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \mathkw{header\ union} \{ \dots,(name,v),\dots \}> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- \mathkw{header\ union} \{ \dots,(name,v),\dots \} : \mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- v : t_{name}, @none
~
By inversion on $H_1$ and $H_2$ we get hypotheses:
~MathPre
H_3: S,D,G |- e : \mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}, d
H_4: \mathkw{has\_field} (\mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}) name t_{name}
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @struct \{\dots,(name, v),\dots\}>
~

Via the application $I_1 \, H_0 \, H_3 \, H_5$ we procure hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- \mathkw{header\ union} \{ \dots,(name,v),\dots \} : \mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}, d
~
By $H_6$, we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- \mathkw{header\ union} \{ \dots,(name,v),\dots \} : \mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}, d
\mathkw{has\_field} (\mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}) name t_{name}
--------------------------------------------------------------------------------------[Expression-Member]
S,D,G |- v : t_{name}, @none
~
we prove subgoal $SG_2$.

#### Case Array-Size-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e.@size : @bit<32>, @none
H_2: <\zeta, \xi, \sigma, e.@size> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, {n_{size}}_u^{32}>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e : t[a], d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- {n_{size}}_u^{32} : @bit<32>, @none
~
By inversion on $H_1$ and $H_2$ we acquire hypotheses:
~MathPre
H_3: S,D,G |- e : t[a], d
H_4: \mathkw{has\_field} t[a] @size @bit<32>
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we obtain the hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
~
$SG_1$ is proven by $H_6$.

TODO: maybe need to modify fixed-int type-checking...

#### Case Array-Next-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e.@next : t, @none
H_2: <\zeta, \xi, \sigma, e.@next> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_{n_{next}}>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : t[a], d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- v_{n_{next}} : t, @none
~
By inversion on $H_1$ and $H_2$ we obtain hypotheses:
~MathPre
H_3: S,D,G |- e : t[a], d
H_4: \mathkw{has\_field} t[a] @next t
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
~
$H_6$ proves subgoal $SG_1$.
Sketchy: By constructing the rule-instance:
~ Infer
S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
\mathkw{has\_field} t[a] @next t
------------------------------------[Expression-Member]
S,D,G |- v_{n_{next}} : t, @none
~
$SG_2$ is proven.

#### Case Array-Last-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e.@last : t, @none
H_2: <\zeta, \xi, \sigma, e.@last> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_{n_{next} - 1}>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : t[a], d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi',\sigma'
SG_2: S,D,G |- v_{n_{next} - 1} : t, @none
~
By inversion on $H_1$ and $H_2$ we obtain hypotheses:
~MathPre
H_3: S,D,G |- e : t[a], d
H_4: \mathkw{has\_field} t[a] @last t
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
~
$H_6$ proves subgoal $SG_1$.
Sketchy: By constructing the rule-instance:
~ Infer
S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
\mathkw{has\_field} t[a] @last t
------------------------------------[Expression-Member]
S,D,G |- v_{n_{next} - 1} : t, @none
~
$SG_2$ is proven.

#### Case Ternary-Op-True
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e_1 ? e_2 : e_3 : t, @none
H_2: <\zeta, \xi, \sigma, e_1 ? e_2 : e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_2>
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : @bool, \_ \Rightarrow <\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', sig_1, @true> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- @true : @bool, \_
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : t, \_ \Rightarrow <\zeta, \xi', \sigma', e_2> \Downarrow_e <\xi'', \sigma'', sig_2, v_2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : t, \_
~
We wish to prove subgoal:
~MathPre
SG_1: S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : t, @none
~
By inversion on $H_1$ and $H_2$ we attain hypotheses:
~MathPre
H_3: S,D,G |- e_1 : @bool, \_
H_4: S,D,G |- e_2 : t, \_
H_5: <\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', sig_1, @true>
H_6: <\zeta, \xi', \sigma', e_2> \Downarrow_e <\xi'', \sigma'', sig_2, v_2>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we earn hypotheses:
~MathPre
H_7: S,D,G \models \xi',\sigma'
H_8: S,D,G |- @true : @bool, \_
~
Via the application $I_2 \, H_7 \, H_4 \, H_6$ we gain hypothesis:
~MathPre
H_9: S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : t, \_
~
which proves our subgoal $SG_1$.

#### Case Ternary-Op-False
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e_1 ? e_2 : e_3 : t, @none
H_2: <\zeta, \xi, \sigma, e_1 ? e_2 : e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_3>
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : @bool, \_ \Rightarrow <\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', sig_1, @false> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- @false : @bool, \_
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_3 : t, \_ \Rightarrow <\zeta, \xi', \sigma', e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_3> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_3 : t, \_
~
We wish to prove subgoal:
~MathPre
SG_1: S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_3 : t, @none
~
By inversion on $H_1$ and $H_2$ we attain hypotheses:
~MathPre
H_3: S,D,G |- e_1 : @bool, \_
H_4: S,D,G |- e_3 : t, \_
H_5: <\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', sig_1, @false>
H_6: <\zeta, \xi', \sigma', e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_3>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we earn hypotheses:
~MathPre
H_7: S,D,G \models \xi',\sigma'
H_8: S,D,G |- @false : @bool, \_
~
Via the application $I_2 \, H_7 \, H_4 \, H_6$ we gain hypothesis:
~MathPre
H_9: S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_3 : t, \_
~
which proves our subgoal $SG_1$.

#### Case Function

Question, when typing the function arguments does $\Delta$ get extended with type-arguments?

We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- f<\overline{\rho}>(\overline{e}) : \tau_{\mathsf{ret}}, @none
H_2: <\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi'', \sigma''''', \mathkw{sig\_continue}, v>
~
We have induction hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- f : function<\overline{X}>(\overline{x:t,d}):t_{\mathsf{ret}}, \_ \Rightarrow <\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{x:t,d}) \to blk> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- (\overline{x:t,d}) \to blk : function<\overline{X}>(\overline{x:t,d}):t_{\mathsf{ret}}, \_
I_2: S,D,G \models \xi',\sigma' \Rightarrow P,S,D,G |- \overline{e:t} \Rightarrow <\zeta, \xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge P,S,D,G \vdash \overline{v:t}
I_3: S,D[\overline{X \to \rho}],G_{\Psi}[\overline{x:t}],@InFunction t |- blk: @returns t -| G_{\Psi}' \Rightarrow <\zeta, \xi_{closure}', \sigma''', blk> \Downarrow_s <\xi_{closure}'', \sigma'''', \mathkw{sig\_return\ v}>\Rightarrow S,D[\overline{X \to \rho}],G_{\Psi}[\overline{x:t}] \models \xi_{closure}',\sigma''' \Rightarrow S,D[\overline{X \to \rho}],G_{\Psi}' \models \xi_{closure}'',\sigma'''' \wedge @sig = returns \wedge sig = \mathkw{sig\_return\ v} \wedge \vdash_v v : \tau_{\mathsf{ret}}
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma'''''
SG_2: \vdash_v v : \tau_{\mathsf{ret}}
~
By inversion on $H_1$ and $H_2$ we amass hypotheses:
~MathPre
H_3: S,D,G |- f : function<\overline{X}>(\overline{x:t,d}):t_{\mathsf{ret}}, \_
H_4: P,S,D,G \vdash \overline{e:t,d}
H_5: \overline{@P_{call} \, e \, d \, t}
H_6: <\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \xi_{closure} \otimes (\overline{x:t,d}) \to blk>
H_7: <\zeta, \xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
H_8: @copyin \, (@push \, \xi_{closure}) \, \sigma'' \, (\overline{x:t,d}) \, \overline{v} = \xi_{closure}',\sigma'''
H_9: <\zeta, \xi_{closure}', \sigma''', blk> \Downarrow_s <\xi_{closure}'', \sigma'''', \mathkw{sig\_return\ v}>
H_{10}: @copyout \, \zeta \, \xi'' \, \xi_{closure}'' \, \sigma'''' \, (\overline{x:t,d}) \, \overline{e} = \sigma'''''
~
Via the application $I_1 \, H_0 \, H_3 \, H_6$ we score hypotheses:
~MathPre
H_{11}: S,D,G \models \xi',\sigma'
H_{12}: S,D,G |- \xi_{closure} \otimes (\overline{x:t,d}) \to blk : function<\overline{X}>(\overline{x:t,d}):t_{\mathsf{ret}}, \_
~
Via the application $I_2 \, H_{11} \, H_4 \, H_7$ we nab hypotheses:
~MathPre
H_{12}: S,D,G \models \xi'',\sigma''
H_{13}: P,S,D,G |- \overline{v:t,d}
~
By means of application $L_9 \, H_{12}$ we obtain hypothesis:
~MathPre
H_{14}: P,S,D[\overline{X \to \rho}],G \models \xi'',\sigma''
~
Invoking the *Necromancer* we resurrect the typing context for the closure:
~MathPre
H_{15}: \Psi \, S \, D[\overline{X \to \rho}] \, G \, \xi_{closure} \, \sigma'' \mapsto G_{\Psi}
~
Under the aegis of application $L_4 \, (C_0 \, H_{15})$ we get hypothesis:
~MathPre
H_{16}: S,D[\overline{X \to \rho}],G_{\Gamma} \models @push \xi_{closure},\sigma''
~
By application $L_2 \, H_{13} \, H_8 \, H_{16}$ we procure hypothesis:
~MathPre
H_{17}: S,D[\overline{X \to \rho}],G_{\Psi}[\overline{x:t}] \models \xi_{closure}',\sigma'''
~
Sketchy: By $H_3$ we know that variable $f \in \Gamma$.
The only rule that inserts a function into the typing context is rule \textsc{Type-Decl-Function}.
Thus by inspection on the typing judgments we obtain hypothesis:
~MathPre
H_{18}: S,D,G_{\Psi} |- @function t x<\overline{X}>(\overline{x: t,d}) blk -| S,D,G_{\Psi}'
~
and by inversion on $H_{18}$ we acquire hypothesis:
~MathPre
H_{19}: S,D[\overline{X \to \rho}],G_{\Psi}[\overline{x:t}],@InFunction t |- blk: @returns t -| G_{\Psi}'
~
By dint of application $I_3 \, H_{19} \, H_9 \, H_{17}$ we get hypotheses:
~MathPre
H_{20}: S,D[\overline{X \to \rho}],G_{\Psi}' \models \xi_{closure}'',\sigma''''
H_{21}: @sig = returns
H_{22}: sig = \mathkw{sig\_return\ v}
H_{23} \vdash_v v : \tau_{\mathsf{ret}}
~
$H_{23}$ proves $SG_2$.

We derive:
~MathPre
H_{24}: C_2 \, H_8 \, : \sigma'' \subseteq \sigma'''
H_{25}: L_8 H_9 : \sigma''' \subseteq \sigma''''
H_{26}: (\sigma'' \subseteq \sigma''' \Rightarrow \sigma''' \subseteq \sigma'''' \Rightarrow \sigma'' \subseteq \sigma'''') \, H_{24} \, H_{25} : \sigma'' \subseteq \sigma''''
H_{27}: L_0 \, h_{26} \, H_{12} : S,D,G \models \xi'',\sigma''''
~
By application $L_3 \, H_4 \, H_{10} \, H_{27} \, H_{20}$ we acquire hypotheses:
~MathPre
H_{28}: S,D,G \models \xi'',\sigma'''''
H_{29}: \sigma'''' \subseteq \sigma'''''
~
and $H_{28}$ proves $SG_1$.

#### Case Masks
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e_1 \texttt{\&\&\&} e_2 : @set<@bit<w>>,@none
H_2: <\zeta, \xi, \sigma, e_1 \texttt{\&\&\&} e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_1 \texttt{\&\&\&} v_2>
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : @bit<w>, \_ \Rightarrow <\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : @bit<w>, \_
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : @bit<w>, \_ \Rightarrow <\zeta, \xi', \sigma, e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : @bit<w>, \_
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'',\sigma''
SG_2: S,D,G |- v_1 \texttt{\&\&\&} v_2 : @set<@bit<w>>,@none
~
By inversion on $H_1$ and $H_2$ we get hypotheses:
~MathPre
H_3: S,D,G |- e_1 : @bit<w>, \_
H_4: S,D,G |- e_2 : @bit<w>, \_
H_5: <\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1>
H_6: <\zeta, \xi', \sigma, e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we procure hypotheses:
~MathPre
H_7: S,D,G \models \xi',\sigma'
H_8: S,D,G |- v_1 : @bit<w>, \_
~
Under the aegis of application $I_2 \, H_7 \, H_4 \, H_6$ we secure hypotheses:
~MathPre
H_9: S,D,G \models \xi'',\sigma''
H_{10}: S,D,G |- v_2 : @bit<w>, \_
~
$H_9$ proves $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : @bit<w>, \_
S,D,G |- v_2 : @bit<w>, \_
------------------------------------------------[Masks]
S,D,G |- v_1 \texttt{\&\&\&} v_2 : @set<@bit<w>>,@none
~
we prove $SG_2$.

#### Case Ranges
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi,\sigma
H_1: S,D,G |- e_1\mathbin{..}e_2 : @set<\tau>, @none
H_2: <\zeta, \xi, \sigma, e_1 \mathbin{..} e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_1 \mathbin{..} v_2>
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_1 : \tau, \_ \Rightarrow <\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v_1 : \tau, \_
I_2: S,D,G \models \xi',\sigma' \Rightarrow S,D,G |- e_2 : \tau, \_ \Rightarrow <\zeta, \xi', \sigma, e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2> \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- v_2 : \tau, \_
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi''
SG_2: S,D,G |- v_1\mathbin{..}v_2 : @set<\tau>, @none
~
By inversion on hypotheses $H_1$ and $H_2$ we land hypotheses:
~MathPre
H_3: S,D,G |- v_1 : \tau, \_
H_4: S,D,G |- v_2 : \tau, \_
H_5: \tau = @bit<w> \lor \tau = @int<w>
H_6: <\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1>
H_7: <\zeta, \xi', \sigma, e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2>
~
By dint of application $I_1 \, H_0 \, H_3 \, H_6$ we obtain hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- v_1 : \tau, \_
~
By virtue of application $I_2 \, H_8 \, H_4 \, H_7$ we get hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'',\sigma''
H_{11}: S,D,G |- v_2 : \tau, \_
~
$H_{10}$ proves $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : \tau, \_
S,D,G |- v_2 : \tau, \_
\tau = @bit<w> \lor \tau = @int<w>
-------------------------[Ranges]
S,D,G |- v_1\mathbin{..}v_2 : @set<\tau>, @none
~
we prove $SG_2$.

## Type Soundness of Statements

### Statement Type Preservation Theorem Statement

TODO: name for statement typing signals and evaluation signals needs to be different.

Statement Preservation requires a predicate on contexts and signals:
~MathPre
\Omega : ctx \to @Prop

\forall @sig,sig
\Omega @InAction \mapsto @sig = returns
\Omega (@InFunction @void) \mapsto @sig = returns
\Omega (@InFunction t) \mapsto @sig = returns \wedge sig = \mathkw{sig\_return\ v} \wedge \vdash_v : \tau
\Omega \_ \mapsto @sig = @unit
~
TODO: definition of $\Omega$ may be incorrect or incomplete.

~MathPre
\forall S,D,G,ctx,s,sig,G',\zeta,\xi,\sigma,\xi',\sigma',
S,D,G,ctx |- s: @sig -| G' \Rightarrow <\zeta, \xi, \sigma, s> \Downarrow_s <\xi', \sigma', sig> \Rightarrow S,D,G \models \xi,\sigma \Rightarrow S,D,G' \models \xi',\sigma' \wedge \Omega ctx
~

### Statement Type Preservation Proof

Introducing variables:
~MathPre
S,D,G,ctx,s,sig,G',\zeta,\xi,\sigma,\xi',\sigma'
~
and assuming hypotheses:
~MathPre
H_0: S,D,G,ctx |- s:sig -| G'
H_1: <\zeta, \xi, \sigma, s> \Downarrow_s <\xi', \sigma', sig>
H_2: S,D,G \models \xi,\sigma
~
we wish to prove the goal:
~MathPre
S,D,G \models \xi',\sigma'
~
We induct on the derivation of:
~MathPre
H_1: <\zeta, \xi, \sigma, s> \Downarrow_s <\xi', \sigma', sig>
~
We assume freely $s$ is free-variable free.

#### Case Assignment
We have hypotheses:
~MathPre
H_0: S,D,G,ctx |- e_l:=e_r:\bot -| G
H_1: <\zeta, \xi, \sigma, e_l := e_r> \Downarrow_s <\xi', \sigma''', sig>
H_2: S,D,G \models \xi,\sigma
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e_r : t,d \Rightarrow \langle \zeta, \xi, \sigma, e \rangle \Downarrow_e \langle \xi', \sigma', \mathkw{sig\_continue}, v \rangle \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : \tau,d
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi',\sigma'''
~

By inversion on $H_0$ and $H_1$ we amass hypotheses:
~MathPre
H_3: \mathkw{lvalue}(e_l)
H_4: S,D,G |- e_l: t,\_
H_5: S,D,G |- e_r: t,\_
H_6: <\zeta, \xi, \sigma, e_r> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
H_7: \mathkw{lv\_of\_expr} \zeta \xi \sigma' e_l = (\xi'', \sigma'', \mathkw{sig\_continue}, lv)
H_8: \mathkw{assign\_lv} \xi' \sigma'' lv v = (\sigma''', sig)
~

Via the application $I_1 \, H_2 \, H_5 \, H_6$ we obtain hypotheses
~MathPre
H_9: S,D,G \models \xi',\sigma'
H_{10}: S,D,G |- v : t,d
~
We may instantiate Lemma 1 as:
~MathPre
L_1: S,D,G \models \xi,\sigma' \Rightarrow S,D,G |- e_l : t,\_ \Rightarrow \mathkw{lv\_of\_expr} \zeta \xi \sigma' e_l = (\xi'', \sigma'', \mathkw{sig\_continue}, @lvalue t lv) \Rightarrow S,D,G \models \xi'',\sigma'' \wedge S,D,G |- lv : t,\_
~

Via the application $L_1 \, (L_0 \, (L_7 \, H_6) \, H_2) \, H_4 \, H_7$ we acquire hypotheses:
~MathPre
H_{11}: S,D,G \models \xi'',\sigma''
H_{12}: S,D,G |- lv : t,\_
~

We may instantiate Lemma 6 as:
~MathPre
L_6: S,D,G |- v : t,d \Rightarrow S,D,G |- lv : t,d \Rightarrow \mathkw{assign\_lvalue} \, \xi' \, \sigma'' \, lv \, v = \sigma''',sig \Rightarrow S,D,G \models \xi',\sigma'' \Rightarrow S,D,G \models \xi',\sigma'''
~

Via the application $L_6 \, H_{10} \, H_{12} \, H_8 \, (L_0 \, (C_1 \, H_7) \, H_9)$ we obtain hypotheses:
~MathPre
H_{13}: S,D,G \models \xi',\sigma'''
~
Subgoal $SG$ is thus proven by $H_{13}$.

#### Case Conditional-Reject
We have hypotheses:
~MathPre
H_0: S,D,G,ctx |- @if (e) s_1 @else s_2:sig_1\wedge{}sig_2 -| G
H_1: <\zeta, \xi, \sigma, @if (e) s1 @else s2> \Downarrow_s <\xi', \sigma', \mathkw{sig\_reject\ v}>
H_2: S,D,G \models \xi,\sigma
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e:@bool,\_ \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_reject\ v}, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v:@bool,\_
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi',\sigma'
~
By inversion on $H_0$ and $H_1$ we collect hypotheses:
~MathPre
H_3: S,D,G |- e:@bool,\_
H_4: S,D,G,ctx |- s_1:sig_1 -| G_1
H_5: S,D,G,ctx |- s_2:sig_2 -| G_2
H_6: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_reject\ v}, v>
~
Through the agency of application $I_1 \, H_2 \, H_3 \, H_6$ we come by hypotheses:
~MathPre
H_7: S,D,G \models \xi',\sigma'
H_8: S,D,G |- v:@bool,\_
~
and $H_7$ proves $SG$.

#### Case If-True
We inherit hypotheses:
~MathPre
H_0: S,D,G,ctx |- @if (e) s :\bot -| G
H_1: <\zeta, \xi, \sigma, @if (e) s> \Downarrow_s <\xi', \sigma'', sig>
H_2: S,D,G \models \xi,\sigma
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : @bool,\_ \Rightarrow \langle \zeta, \xi, \sigma, e \rangle \Downarrow_e \langle \xi', \sigma', sig, @true \rangle \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- @true : @bool,\_
I_2: S,D,G,ctx |- s:\bot -| G' \Rightarrow <\zeta, @push \xi', \sigma', s> \Downarrow_s <\xi'', \sigma'', sig> \Rightarrow S,D,G \models @push \xi',\sigma' \Rightarrow S,D,G' \models \xi'',\sigma''
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi',\sigma''
~
By inversion on $H_0$ and $H_1$ we obtain hypotheses:
~MathPre
H_3: S,D,G |- e:@bool,\_
H_4: S,D,G,ctx |- s:sig -| G'
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, true>
H_6: <\zeta, @push \xi', \sigma', s> \Downarrow_s <\xi'', \sigma'', sig>
~
Under the aegis of application $I_1 \, H_2 \, H_3 \, H_5$ we get hypotheses:
~MathPre
H_7: S,D,G \models \xi',\sigma'
H_8: S,D,G |- @true : @bool,\_
~
By the application $L_0 \, (L_8 \, H_6)$ we acquire hypothesis:
~MathPre
H_9: S,D,G \models \xi',\sigma''
~
and by $H_9$ subgoal $SG$ is proven.

#### Case If-False
We have hypotheses:
~MathPre
H_0: S,D,G,ctx |- @if (e) s :\bot -| G
H_1: <\zeta, \xi, \sigma, @if (e) s> \Downarrow_s <\xi', \sigma', sig>
H_2: S,D,G \models \xi,\sigma
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : @bool,\_ \Rightarrow \langle \zeta, \xi, \sigma, e \rangle \Downarrow_e \langle \xi', \sigma', sig, @false \rangle \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- @false : @bool,\_
~
We wish to prove:
~MathPre
SG: S,D,G \models \xi',\sigma'
~
By inversion on hypotheses $H_0$ and $H_1$ we inherit hypotheses:
~MathPre
H_3: S,D,G |- e:@bool,\_
H_4: S,D,G,ctx |- s:sig -| G'
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @false>
~
Via application $I_1 \, H_2 \, H_3 \, H_5$ we obtain hypotheses:
~MathPre
H_6: S,D,G \models \xi',\sigma'
H_7: S,D,G |- @false : @bool,\_
~
and by $H_6$ we prove $SG$.

#### Case If-Else-True
We have hypotheses:
~MathPre
H_0: S,D,G,ctx |- @if (e) s_1 @else s_2:sig_1\wedge{}sig_2 -| G
H_1: <\zeta, \xi, \sigma, @if (e) s_1 @else s_2> \Downarrow_s <\xi', \sigma'', sig>
H_2: S,D,G \models \xi,\sigma
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e:@bool,\_ \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @true> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- @true : @bool,\_
I_2: S,D,G,ctx |- s_1:sig_1 -| G_1 \Rightarrow <\zeta, @push \xi', \sigma', s1> \Downarrow_s <\xi'', \sigma'', sig> \Rightarrow S,D,G \models \xi',\sigma' \Rightarrow S,D,G_1 \models \xi'',\sigma''
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi',\sigma''
~
By inversion on $H_0$ and $H_1$ we amass hypotheses:
~MathPre
H_3: S,D,G |- e:@bool,\_
H_4: S,D,G,ctx |- s_1:sig_1 -| G_1
H_5: S,D,G,ctx |- s_2:sig_2 -| G_2
H_6: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @true>
H_7: <\zeta, @push \xi', \sigma', s_1> \Downarrow_s <\xi'', \sigma'', sig>
~
Via the application $I_1 \, H_2 \, H_3 \, H_6$ we acquire hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- @true : @bool, \_
~
By the application $L_0 \, (L_8 \, H_7) \, H_8$ we get hypothesis:
~MathPre
H_{10}: S,D,G \models \xi',\sigma''
~
and $H_{10}$ proves $SG$.

#### Case If-Else-False
We have hypotheses:
~MathPre
H_0: S,D,G,ctx |- @if (e) s_1 @else s_2:sig_1\wedge{}sig_2 -| G
H_1: <\zeta, \xi, \sigma, @if (e) s_1 @else s_2> \Downarrow_s <\xi', \sigma'', sig>
H_2: S,D,G \models \xi,\sigma
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e:@bool,\_ \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @false> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- @false : @bool,\_
I_2: S,D,G,ctx |- s_2:sig_2 -| G_2 \Rightarrow <\zeta, @push \xi', \sigma', s_2> \Downarrow_s <\xi'', \sigma'', sig> \Rightarrow S,D,G \models \xi',\sigma' \Rightarrow S,D,G_2 \models \xi'',\sigma''
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi',\sigma''
~
By inversion on $H_0$ and $H_1$ we amass hypotheses:
~MathPre
H_3: S,D,G |- e:@bool,\_
H_4: S,D,G,ctx |- s_1:sig_1 -| G_1
H_5: S,D,G,ctx |- s_2:sig_2 -| G_2
H_6: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @false>
H_7: <\zeta, @push \xi', \sigma', s_2> \Downarrow_s <\xi'', \sigma'', sig>
~
Via the application $I_1 \, H_2 \, H_3 \, H_6$ we acquire hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- @true : @bool, \_
~
By the application $L_0 \, (L_8 \, H_7) \, H_8$ we get hypothesis:
~MathPre
H_{10}: S,D,G \models \xi',\sigma''
~
and $H_{10}$ proves $SG$.

#### Case Block
We have hypotheses:
~MathPre
H_0: S,D,G,ctx |- \{\overline{s}\}:sig -| G
H_1: <\zeta, \xi, \sigma, \{s_1; ... s_n;\}> \Downarrow_s <\xi', \sigma', sig>
H_2: S,D,G \models \xi,\sigma
~
and induction hypothesis:
~MathPre
I_1: <\zeta, \xi, \sigma, \overline{s}> \Downarrow_s <\xi', \sigma', sig> \Rightarrow S,D,G \models \xi,\sigma \Rightarrow S,D,G \models \xi',\sigma'
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi,\sigma'
~
By inversion on $H_0$ and $H_1$ we assemble hypotheses:
~MathPre
H_3: S,D,G,ctx |- \overline{s}:sig -| G'
H_4: <\zeta, \xi, \sigma, \overline{s}> \Downarrow_s <\xi', \sigma', sig>
~
By the application $L_0 \, (L_8 \, H_4) \, H_2$ we get hypothesis:
~MathPre
H_5: S,D,G \models \xi,\sigma'
~

#### Case Exit-Continue
We have hypotheses:
~MathPre
H_0: S,D,G,@InParserState |- @exit:@returns -| G
H_1: <\zeta, \xi, \sigma, ;> \Downarrow_s <\xi, \sigma, sig>
H_2: S,D,G \models \xi,\sigma
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi,\sigma
~
$H_2$ proves $SG$.

#### Case Empty
We have hypotheses:
~MathPre
H_0: S,D,G,ctx |- \mathkw{;}:\bot -| G
H_1: <\zeta, \xi, \sigma, ;> \Downarrow_s <\xi, \sigma, sig>
H_2: S,D,G \models \xi,\sigma
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi,\sigma
~
$H_2$ proves $SG$.

#### Case Return-Void
We have hypotheses:
~MathPre
H_0: S,D,G,ctx |- @return:@returns -| G
H_1: <\zeta, \xi, \sigma, @return> \Downarrow_s <\xi, \sigma, \mathkw{sig\_return\ None}>
H_2: S,D,G \models \xi,\sigma
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi,\sigma
~
$H_2$ proves $SG$.

#### Case Return-Value
We have hypotheses:
~MathPre
H_0: S,D,G,@InFunction t |- @return e:@returns -| G
H_1: <\zeta, \xi, \sigma, @return e> \Downarrow_s <\xi', \sigma', \mathkw{sig\_return\ v}>
H_2: S,D,G \models \xi,\sigma
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : t,\_ \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : t,\_
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi',\sigma'
~
By inversion on $H_0$ and $H_1$ we get hypotheses:
~MathPre
H_3: S,D,G |- e : t,\_
H_4: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
By virtue of the application $I_1 \, H_2 \, H_3 \, H_4$ we obtain hypotheses:
~MathPre
H_5: S,D,G \models \xi',\sigma'
H_6: S,D,G |- v : t, \_
~
and $H_5$ proves $SG$.

#### Case Switch-No-Match
We have hypotheses:
~MathPre
H_0: S,D,G,@InControl |- @switch (e) \{ case1, \dots, case_n \}:\bot -| G
H_1: <\zeta, \xi, \sigma, @switch (e) \{\overline{case}\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}>
H_2: S,D,G \models \xi,\sigma
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : @enum X,\_ \{ \overline{m} \} \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, name_1.name_2> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : @enum X \{ \overline{m} \}, \_
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi',\sigma'
~
By inversion on hypotheses $H_0$ and $H_1$ we profit hypotheses:
~MathPre
H_3: S,D,G |- e : @enum X \{ \overline{m} \}, \_
H_4: \forall i. S,D,G |- \mathkw{case\_ok}_X case_i
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, name_1.name_2>
H_6: \mathkw{match\_switch\_case} \overline{case} name_2 = None
~
By means of application $I_1 \, H_2 \,H_3 \, H_5$ we procure hypotheses:
~MathPre
H_7: S,D,G \models \xi',\sigma'
H_8: S,D,G |- e : @enum X \{ \overline{m} \}, \_
~
and $H_7$ proves $SG$.

#### Case Switch-Match
We have hypotheses:
~MathPre
H_0: S,D,G,@InControl |- @switch (e) \{ case1, \dots, case_n \}:\bot -| G
H_1: <\zeta, \xi, \sigma, @switch (e) \{\overline{case}\}> \Downarrow_s <\xi', \sigma'', sig>
H_2: S,D,G \models \xi,\sigma
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi,\sigma \Rightarrow S,D,G |- e : @enum X,\_ \{ \overline{m} \} \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, name_1.name_2> \Rightarrow S,D,G \models \xi',\sigma' \wedge S,D,G |- v : @enum X \{ \overline{m} \}, \_
~
We wish to prove subgoal:
~MathPre
SG: S,D,G \models \xi',\sigma''
~
By inversion on $H_0$ and $H_1$ we garner hypotheses:
~MathPre
H_3: S,D,G |- e : @enum X \{ \overline{m} \}
H_4: \forall i. S,D,G |- \mathkw{case\_ok}_X case_i
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, name_1.name_2>
H_6: \mathkw{match\_switch\_case} \overline{case} name_2 = Some\ blk
H_7: <\zeta, @push \xi', \sigma', blk> \Downarrow_s <\xi'', \sigma'', sig>
~
TODO: where is $\mathkw{case\_ok}$ defined?

Via application $I_1 \, H_2 \, H_3 \, H_5$ we obtain hypotheses:
~MathPre
H_8: S,D,G \models \xi',\sigma'
H_9: S,D,G |- v : @enum X \{ \overline{m} \}, \_
~

As a result of application $L_0 \, (L_8 \, H_7) \, H_8$ we secure hypothesis:
~MathPre
H_{10}: S,D,G \models \xi',\sigma''
~
and $H_{10}$ proves $SG$.
